/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.10
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Kubernetes.DotNet.Client;
using Kubernetes.DotNet.Model;

namespace Kubernetes.DotNet.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICore_v1Api : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectDeleteNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectDeleteNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectDeleteNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectDeleteNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectDeleteNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectDeleteNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectDeleteNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectDeleteNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectDeleteNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectDeleteNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectDeleteNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectDeleteNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedPodAttach (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedPodAttachWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedPodExec (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedPodExecWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedPodPortforward (string name, string _namespace, int? ports = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedPodPortforwardWithHttpInfo (string name, string _namespace, int? ports = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectGetNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectGetNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectHeadNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectHeadNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectHeadNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectHeadNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectHeadNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectHeadNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectHeadNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectHeadNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectHeadNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectHeadNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectHeadNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectHeadNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectOptionsNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectOptionsNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectOptionsNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectOptionsNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectOptionsNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectOptionsNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectOptionsNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectOptionsNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectOptionsNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectOptionsNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectOptionsNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectOptionsNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectPatchNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPatchNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectPatchNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPatchNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectPatchNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPatchNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectPatchNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPatchNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectPatchNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPatchNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectPatchNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPatchNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedPodAttach (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedPodAttachWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedPodExec (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedPodExecWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedPodPortforward (string name, string _namespace, int? ports = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedPodPortforwardWithHttpInfo (string name, string _namespace, int? ports = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectPostNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPostNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectPutNamespacedPodProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPutNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        string ConnectPutNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPutNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectPutNamespacedServiceProxy (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPutNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        string ConnectPutNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPutNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectPutNodeProxy (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPutNodeProxyWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        string ConnectPutNodeProxyWithPath (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ConnectPutNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace CreateNamespace (V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> CreateNamespaceWithHttpInfo (V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Binding
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Binding</returns>
        V1Binding CreateNamespacedBinding (string _namespace, V1Binding body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Binding
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Binding</returns>
        ApiResponse<V1Binding> CreateNamespacedBindingWithHttpInfo (string _namespace, V1Binding body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        V1ConfigMap CreateNamespacedConfigMap (string _namespace, V1ConfigMap body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        ApiResponse<V1ConfigMap> CreateNamespacedConfigMapWithHttpInfo (string _namespace, V1ConfigMap body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Endpoints</returns>
        V1Endpoints CreateNamespacedEndpoints (string _namespace, V1Endpoints body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        ApiResponse<V1Endpoints> CreateNamespacedEndpointsWithHttpInfo (string _namespace, V1Endpoints body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Event</returns>
        V1Event CreateNamespacedEvent (string _namespace, V1Event body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        ApiResponse<V1Event> CreateNamespacedEventWithHttpInfo (string _namespace, V1Event body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1LimitRange</returns>
        V1LimitRange CreateNamespacedLimitRange (string _namespace, V1LimitRange body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        ApiResponse<V1LimitRange> CreateNamespacedLimitRangeWithHttpInfo (string _namespace, V1LimitRange body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim CreateNamespacedPersistentVolumeClaim (string _namespace, V1PersistentVolumeClaim body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> CreateNamespacedPersistentVolumeClaimWithHttpInfo (string _namespace, V1PersistentVolumeClaim body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod CreateNamespacedPod (string _namespace, V1Pod body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> CreateNamespacedPodWithHttpInfo (string _namespace, V1Pod body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create binding of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Binding</returns>
        V1Binding CreateNamespacedPodBinding (string name, string _namespace, V1Binding body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create binding of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Binding</returns>
        ApiResponse<V1Binding> CreateNamespacedPodBindingWithHttpInfo (string name, string _namespace, V1Binding body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create eviction of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1Eviction</returns>
        V1beta1Eviction CreateNamespacedPodEviction (string name, string _namespace, V1beta1Eviction body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create eviction of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1Eviction</returns>
        ApiResponse<V1beta1Eviction> CreateNamespacedPodEvictionWithHttpInfo (string name, string _namespace, V1beta1Eviction body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        V1PodTemplate CreateNamespacedPodTemplate (string _namespace, V1PodTemplate body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        ApiResponse<V1PodTemplate> CreateNamespacedPodTemplateWithHttpInfo (string _namespace, V1PodTemplate body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController CreateNamespacedReplicationController (string _namespace, V1ReplicationController body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> CreateNamespacedReplicationControllerWithHttpInfo (string _namespace, V1ReplicationController body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota CreateNamespacedResourceQuota (string _namespace, V1ResourceQuota body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> CreateNamespacedResourceQuotaWithHttpInfo (string _namespace, V1ResourceQuota body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Secret</returns>
        V1Secret CreateNamespacedSecret (string _namespace, V1Secret body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        ApiResponse<V1Secret> CreateNamespacedSecretWithHttpInfo (string _namespace, V1Secret body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service CreateNamespacedService (string _namespace, V1Service body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> CreateNamespacedServiceWithHttpInfo (string _namespace, V1Service body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        V1ServiceAccount CreateNamespacedServiceAccount (string _namespace, V1ServiceAccount body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        ApiResponse<V1ServiceAccount> CreateNamespacedServiceAccountWithHttpInfo (string _namespace, V1ServiceAccount body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node CreateNode (V1Node body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> CreateNodeWithHttpInfo (V1Node body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume CreatePersistentVolume (V1PersistentVolume body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> CreatePersistentVolumeWithHttpInfo (V1PersistentVolume body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedConfigMap (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedConfigMapWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedEndpoints (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedEndpointsWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedEvent (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedEventWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedLimitRange (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedLimitRangeWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedPersistentVolumeClaim (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedPod (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedPodWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedPodTemplate (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedPodTemplateWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedReplicationController (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedReplicationControllerWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedResourceQuota (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedResourceQuotaWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedSecret (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedSecretWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedServiceAccount (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedServiceAccountWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNode (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNodeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionPersistentVolume (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionPersistentVolumeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespace (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespaceWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedConfigMap (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedConfigMapWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedEndpoints (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedEndpointsWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedEvent (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedEventWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedLimitRange (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedLimitRangeWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedPersistentVolumeClaim (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedPod (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedPodWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedPodTemplate (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedPodTemplateWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedReplicationController (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedResourceQuota (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedSecret (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedSecretWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedService (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedServiceWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedServiceAccount (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedServiceAccountWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNode (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNodeWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeletePersistentVolume (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeletePersistentVolumeWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>V1APIResourceList</returns>
        V1APIResourceList GetAPIResources ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of V1APIResourceList</returns>
        ApiResponse<V1APIResourceList> GetAPIResourcesWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list objects of kind ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ComponentStatusList</returns>
        V1ComponentStatusList ListComponentStatus (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list objects of kind ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ComponentStatusList</returns>
        ApiResponse<V1ComponentStatusList> ListComponentStatusWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ConfigMapList</returns>
        V1ConfigMapList ListConfigMapForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMapList</returns>
        ApiResponse<V1ConfigMapList> ListConfigMapForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EndpointsList</returns>
        V1EndpointsList ListEndpointsForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EndpointsList</returns>
        ApiResponse<V1EndpointsList> ListEndpointsForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EventList</returns>
        V1EventList ListEventForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EventList</returns>
        ApiResponse<V1EventList> ListEventForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1LimitRangeList</returns>
        V1LimitRangeList ListLimitRangeForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1LimitRangeList</returns>
        ApiResponse<V1LimitRangeList> ListLimitRangeForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1NamespaceList</returns>
        V1NamespaceList ListNamespace (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1NamespaceList</returns>
        ApiResponse<V1NamespaceList> ListNamespaceWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ConfigMapList</returns>
        V1ConfigMapList ListNamespacedConfigMap (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMapList</returns>
        ApiResponse<V1ConfigMapList> ListNamespacedConfigMapWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EndpointsList</returns>
        V1EndpointsList ListNamespacedEndpoints (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EndpointsList</returns>
        ApiResponse<V1EndpointsList> ListNamespacedEndpointsWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EventList</returns>
        V1EventList ListNamespacedEvent (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EventList</returns>
        ApiResponse<V1EventList> ListNamespacedEventWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1LimitRangeList</returns>
        V1LimitRangeList ListNamespacedLimitRange (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1LimitRangeList</returns>
        ApiResponse<V1LimitRangeList> ListNamespacedLimitRangeWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PersistentVolumeClaimList</returns>
        V1PersistentVolumeClaimList ListNamespacedPersistentVolumeClaim (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaimList</returns>
        ApiResponse<V1PersistentVolumeClaimList> ListNamespacedPersistentVolumeClaimWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodList</returns>
        V1PodList ListNamespacedPod (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodList</returns>
        ApiResponse<V1PodList> ListNamespacedPodWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodTemplateList</returns>
        V1PodTemplateList ListNamespacedPodTemplate (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplateList</returns>
        ApiResponse<V1PodTemplateList> ListNamespacedPodTemplateWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ReplicationControllerList</returns>
        V1ReplicationControllerList ListNamespacedReplicationController (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationControllerList</returns>
        ApiResponse<V1ReplicationControllerList> ListNamespacedReplicationControllerWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ResourceQuotaList</returns>
        V1ResourceQuotaList ListNamespacedResourceQuota (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuotaList</returns>
        ApiResponse<V1ResourceQuotaList> ListNamespacedResourceQuotaWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1SecretList</returns>
        V1SecretList ListNamespacedSecret (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1SecretList</returns>
        ApiResponse<V1SecretList> ListNamespacedSecretWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceList</returns>
        V1ServiceList ListNamespacedService (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceList</returns>
        ApiResponse<V1ServiceList> ListNamespacedServiceWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceAccountList</returns>
        V1ServiceAccountList ListNamespacedServiceAccount (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccountList</returns>
        ApiResponse<V1ServiceAccountList> ListNamespacedServiceAccountWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1NodeList</returns>
        V1NodeList ListNode (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1NodeList</returns>
        ApiResponse<V1NodeList> ListNodeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PersistentVolumeList</returns>
        V1PersistentVolumeList ListPersistentVolume (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeList</returns>
        ApiResponse<V1PersistentVolumeList> ListPersistentVolumeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PersistentVolumeClaimList</returns>
        V1PersistentVolumeClaimList ListPersistentVolumeClaimForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaimList</returns>
        ApiResponse<V1PersistentVolumeClaimList> ListPersistentVolumeClaimForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodList</returns>
        V1PodList ListPodForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodList</returns>
        ApiResponse<V1PodList> ListPodForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodTemplateList</returns>
        V1PodTemplateList ListPodTemplateForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplateList</returns>
        ApiResponse<V1PodTemplateList> ListPodTemplateForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ReplicationControllerList</returns>
        V1ReplicationControllerList ListReplicationControllerForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationControllerList</returns>
        ApiResponse<V1ReplicationControllerList> ListReplicationControllerForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ResourceQuotaList</returns>
        V1ResourceQuotaList ListResourceQuotaForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuotaList</returns>
        ApiResponse<V1ResourceQuotaList> ListResourceQuotaForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1SecretList</returns>
        V1SecretList ListSecretForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1SecretList</returns>
        ApiResponse<V1SecretList> ListSecretForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceAccountList</returns>
        V1ServiceAccountList ListServiceAccountForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccountList</returns>
        ApiResponse<V1ServiceAccountList> ListServiceAccountForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceList</returns>
        V1ServiceList ListServiceForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceList</returns>
        ApiResponse<V1ServiceList> ListServiceForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace PatchNamespace (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> PatchNamespaceWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace PatchNamespaceStatus (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> PatchNamespaceStatusWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        V1ConfigMap PatchNamespacedConfigMap (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        ApiResponse<V1ConfigMap> PatchNamespacedConfigMapWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Endpoints</returns>
        V1Endpoints PatchNamespacedEndpoints (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        ApiResponse<V1Endpoints> PatchNamespacedEndpointsWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Event</returns>
        V1Event PatchNamespacedEvent (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        ApiResponse<V1Event> PatchNamespacedEventWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1LimitRange</returns>
        V1LimitRange PatchNamespacedLimitRange (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        ApiResponse<V1LimitRange> PatchNamespacedLimitRangeWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim PatchNamespacedPersistentVolumeClaim (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim PatchNamespacedPersistentVolumeClaimStatus (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod PatchNamespacedPod (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> PatchNamespacedPodWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod PatchNamespacedPodStatus (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> PatchNamespacedPodStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        V1PodTemplate PatchNamespacedPodTemplate (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        ApiResponse<V1PodTemplate> PatchNamespacedPodTemplateWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController PatchNamespacedReplicationController (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> PatchNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Scale</returns>
        V1Scale PatchNamespacedReplicationControllerScale (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Scale</returns>
        ApiResponse<V1Scale> PatchNamespacedReplicationControllerScaleWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController PatchNamespacedReplicationControllerStatus (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> PatchNamespacedReplicationControllerStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota PatchNamespacedResourceQuota (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> PatchNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota PatchNamespacedResourceQuotaStatus (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> PatchNamespacedResourceQuotaStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Secret</returns>
        V1Secret PatchNamespacedSecret (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        ApiResponse<V1Secret> PatchNamespacedSecretWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service PatchNamespacedService (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> PatchNamespacedServiceWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        V1ServiceAccount PatchNamespacedServiceAccount (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        ApiResponse<V1ServiceAccount> PatchNamespacedServiceAccountWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service PatchNamespacedServiceStatus (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> PatchNamespacedServiceStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node PatchNode (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> PatchNodeWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node PatchNodeStatus (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> PatchNodeStatusWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume PatchPersistentVolume (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> PatchPersistentVolumeWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume PatchPersistentVolumeStatus (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> PatchPersistentVolumeStatusWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyDELETENamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyDELETENamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyDELETENamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyDELETENamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyDELETENamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyDELETENamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyDELETENamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyDELETENamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyDELETENode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyDELETENodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyDELETENodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyDELETENodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyGETNamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyGETNamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyGETNamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyGETNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyGETNamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyGETNamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyGETNamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyGETNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyGETNode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyGETNodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyGETNodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyGETNodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyHEADNamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyHEADNamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyHEADNamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyHEADNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyHEADNamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyHEADNamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyHEADNamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyHEADNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyHEADNode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyHEADNodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyHEADNodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyHEADNodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyOPTIONSNamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyOPTIONSNamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyOPTIONSNamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyOPTIONSNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyOPTIONSNamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyOPTIONSNamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyOPTIONSNamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyOPTIONSNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyOPTIONSNode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyOPTIONSNodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyOPTIONSNodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyOPTIONSNodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyPATCHNamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPATCHNamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPATCHNamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPATCHNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyPATCHNamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPATCHNamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPATCHNamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPATCHNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyPATCHNode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPATCHNodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPATCHNodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPATCHNodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyPOSTNamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPOSTNamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPOSTNamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPOSTNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyPOSTNamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPOSTNamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPOSTNamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPOSTNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyPOSTNode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPOSTNodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPOSTNodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPOSTNodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyPUTNamespacedPod (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPUTNamespacedPodWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPUTNamespacedPodWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPUTNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        string ProxyPUTNamespacedService (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPUTNamespacedServiceWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPUTNamespacedServiceWithPath (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPUTNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        string ProxyPUTNode (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPUTNodeWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        string ProxyPUTNodeWithPath (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ProxyPUTNodeWithPathWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ComponentStatus</returns>
        V1ComponentStatus ReadComponentStatus (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ComponentStatus</returns>
        ApiResponse<V1ComponentStatus> ReadComponentStatusWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace ReadNamespace (string name, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> ReadNamespaceWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace ReadNamespaceStatus (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> ReadNamespaceStatusWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        V1ConfigMap ReadNamespacedConfigMap (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        ApiResponse<V1ConfigMap> ReadNamespacedConfigMapWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Endpoints</returns>
        V1Endpoints ReadNamespacedEndpoints (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        ApiResponse<V1Endpoints> ReadNamespacedEndpointsWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Event</returns>
        V1Event ReadNamespacedEvent (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        ApiResponse<V1Event> ReadNamespacedEventWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1LimitRange</returns>
        V1LimitRange ReadNamespacedLimitRange (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        ApiResponse<V1LimitRange> ReadNamespacedLimitRangeWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim ReadNamespacedPersistentVolumeClaim (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim ReadNamespacedPersistentVolumeClaimStatus (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimStatusWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod ReadNamespacedPod (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> ReadNamespacedPodWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read log of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        string ReadNamespacedPodLog (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read log of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ReadNamespacedPodLogWithHttpInfo (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod ReadNamespacedPodStatus (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> ReadNamespacedPodStatusWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        V1PodTemplate ReadNamespacedPodTemplate (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        ApiResponse<V1PodTemplate> ReadNamespacedPodTemplateWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController ReadNamespacedReplicationController (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> ReadNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Scale</returns>
        V1Scale ReadNamespacedReplicationControllerScale (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Scale</returns>
        ApiResponse<V1Scale> ReadNamespacedReplicationControllerScaleWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController ReadNamespacedReplicationControllerStatus (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> ReadNamespacedReplicationControllerStatusWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota ReadNamespacedResourceQuota (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> ReadNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota ReadNamespacedResourceQuotaStatus (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> ReadNamespacedResourceQuotaStatusWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Secret</returns>
        V1Secret ReadNamespacedSecret (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        ApiResponse<V1Secret> ReadNamespacedSecretWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service ReadNamespacedService (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> ReadNamespacedServiceWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        V1ServiceAccount ReadNamespacedServiceAccount (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        ApiResponse<V1ServiceAccount> ReadNamespacedServiceAccountWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service ReadNamespacedServiceStatus (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> ReadNamespacedServiceStatusWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node ReadNode (string name, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> ReadNodeWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node ReadNodeStatus (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> ReadNodeStatusWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume ReadPersistentVolume (string name, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> ReadPersistentVolumeWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume ReadPersistentVolumeStatus (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> ReadPersistentVolumeStatusWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace ReplaceNamespace (string name, V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> ReplaceNamespaceWithHttpInfo (string name, V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace finalize of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace ReplaceNamespaceFinalize (string name, V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace finalize of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> ReplaceNamespaceFinalizeWithHttpInfo (string name, V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        V1Namespace ReplaceNamespaceStatus (string name, V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        ApiResponse<V1Namespace> ReplaceNamespaceStatusWithHttpInfo (string name, V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        V1ConfigMap ReplaceNamespacedConfigMap (string name, string _namespace, V1ConfigMap body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        ApiResponse<V1ConfigMap> ReplaceNamespacedConfigMapWithHttpInfo (string name, string _namespace, V1ConfigMap body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Endpoints</returns>
        V1Endpoints ReplaceNamespacedEndpoints (string name, string _namespace, V1Endpoints body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        ApiResponse<V1Endpoints> ReplaceNamespacedEndpointsWithHttpInfo (string name, string _namespace, V1Endpoints body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Event</returns>
        V1Event ReplaceNamespacedEvent (string name, string _namespace, V1Event body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        ApiResponse<V1Event> ReplaceNamespacedEventWithHttpInfo (string name, string _namespace, V1Event body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1LimitRange</returns>
        V1LimitRange ReplaceNamespacedLimitRange (string name, string _namespace, V1LimitRange body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        ApiResponse<V1LimitRange> ReplaceNamespacedLimitRangeWithHttpInfo (string name, string _namespace, V1LimitRange body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim ReplaceNamespacedPersistentVolumeClaim (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        V1PersistentVolumeClaim ReplaceNamespacedPersistentVolumeClaimStatus (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        ApiResponse<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimStatusWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod ReplaceNamespacedPod (string name, string _namespace, V1Pod body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> ReplaceNamespacedPodWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        V1Pod ReplaceNamespacedPodStatus (string name, string _namespace, V1Pod body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        ApiResponse<V1Pod> ReplaceNamespacedPodStatusWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        V1PodTemplate ReplaceNamespacedPodTemplate (string name, string _namespace, V1PodTemplate body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        ApiResponse<V1PodTemplate> ReplaceNamespacedPodTemplateWithHttpInfo (string name, string _namespace, V1PodTemplate body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController ReplaceNamespacedReplicationController (string name, string _namespace, V1ReplicationController body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> ReplaceNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Scale</returns>
        V1Scale ReplaceNamespacedReplicationControllerScale (string name, string _namespace, V1Scale body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Scale</returns>
        ApiResponse<V1Scale> ReplaceNamespacedReplicationControllerScaleWithHttpInfo (string name, string _namespace, V1Scale body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        V1ReplicationController ReplaceNamespacedReplicationControllerStatus (string name, string _namespace, V1ReplicationController body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        ApiResponse<V1ReplicationController> ReplaceNamespacedReplicationControllerStatusWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota ReplaceNamespacedResourceQuota (string name, string _namespace, V1ResourceQuota body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> ReplaceNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        V1ResourceQuota ReplaceNamespacedResourceQuotaStatus (string name, string _namespace, V1ResourceQuota body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        ApiResponse<V1ResourceQuota> ReplaceNamespacedResourceQuotaStatusWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Secret</returns>
        V1Secret ReplaceNamespacedSecret (string name, string _namespace, V1Secret body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        ApiResponse<V1Secret> ReplaceNamespacedSecretWithHttpInfo (string name, string _namespace, V1Secret body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service ReplaceNamespacedService (string name, string _namespace, V1Service body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> ReplaceNamespacedServiceWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        V1ServiceAccount ReplaceNamespacedServiceAccount (string name, string _namespace, V1ServiceAccount body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        ApiResponse<V1ServiceAccount> ReplaceNamespacedServiceAccountWithHttpInfo (string name, string _namespace, V1ServiceAccount body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        V1Service ReplaceNamespacedServiceStatus (string name, string _namespace, V1Service body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        ApiResponse<V1Service> ReplaceNamespacedServiceStatusWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node ReplaceNode (string name, V1Node body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> ReplaceNodeWithHttpInfo (string name, V1Node body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        V1Node ReplaceNodeStatus (string name, V1Node body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        ApiResponse<V1Node> ReplaceNodeStatusWithHttpInfo (string name, V1Node body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume ReplacePersistentVolume (string name, V1PersistentVolume body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> ReplacePersistentVolumeWithHttpInfo (string name, V1PersistentVolume body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        V1PersistentVolume ReplacePersistentVolumeStatus (string name, V1PersistentVolume body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        ApiResponse<V1PersistentVolume> ReplacePersistentVolumeStatusWithHttpInfo (string name, V1PersistentVolume body, string pretty = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectDeleteNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectDeleteNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectDeleteNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectDeleteNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectDeleteNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectDeleteNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect DELETE requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedPodAttachAsync (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodAttachAsyncWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedPodExecAsync (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodExecAsyncWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedPodPortforwardAsync (string name, string _namespace, int? ports = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodPortforwardAsyncWithHttpInfo (string name, string _namespace, int? ports = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectGetNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect GET requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectHeadNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectHeadNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectHeadNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectHeadNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectHeadNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectHeadNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect HEAD requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectOptionsNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectOptionsNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectOptionsNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectOptionsNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectOptionsNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectOptionsNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect OPTIONS requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPatchNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPatchNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPatchNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPatchNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPatchNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPatchNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PATCH requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedPodAttachAsync (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to attach of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodAttachAsyncWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedPodExecAsync (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to exec of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodExecAsyncWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedPodPortforwardAsync (string name, string _namespace, int? ports = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to portforward of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodPortforwardAsyncWithHttpInfo (string name, string _namespace, int? ports = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPostNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect POST requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPutNamespacedPodProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPutNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPutNamespacedServiceProxyAsync (string name, string _namespace, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPutNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPutNodeProxyAsync (string name, string path = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNodeProxyAsyncWithHttpInfo (string name, string path = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ConnectPutNodeProxyWithPathAsync (string name, string path, string path2 = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// connect PUT requests to proxy of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> CreateNamespaceAsync (V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> CreateNamespaceAsyncWithHttpInfo (V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Binding
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Binding</returns>
        System.Threading.Tasks.Task<V1Binding> CreateNamespacedBindingAsync (string _namespace, V1Binding body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Binding
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Binding)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Binding>> CreateNamespacedBindingAsyncWithHttpInfo (string _namespace, V1Binding body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        System.Threading.Tasks.Task<V1ConfigMap> CreateNamespacedConfigMapAsync (string _namespace, V1ConfigMap body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> CreateNamespacedConfigMapAsyncWithHttpInfo (string _namespace, V1ConfigMap body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        System.Threading.Tasks.Task<V1Endpoints> CreateNamespacedEndpointsAsync (string _namespace, V1Endpoints body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> CreateNamespacedEndpointsAsyncWithHttpInfo (string _namespace, V1Endpoints body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Event</returns>
        System.Threading.Tasks.Task<V1Event> CreateNamespacedEventAsync (string _namespace, V1Event body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Event>> CreateNamespacedEventAsyncWithHttpInfo (string _namespace, V1Event body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        System.Threading.Tasks.Task<V1LimitRange> CreateNamespacedLimitRangeAsync (string _namespace, V1LimitRange body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> CreateNamespacedLimitRangeAsyncWithHttpInfo (string _namespace, V1LimitRange body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> CreateNamespacedPersistentVolumeClaimAsync (string _namespace, V1PersistentVolumeClaim body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> CreateNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string _namespace, V1PersistentVolumeClaim body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> CreateNamespacedPodAsync (string _namespace, V1Pod body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> CreateNamespacedPodAsyncWithHttpInfo (string _namespace, V1Pod body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create binding of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Binding</returns>
        System.Threading.Tasks.Task<V1Binding> CreateNamespacedPodBindingAsync (string name, string _namespace, V1Binding body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create binding of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Binding)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Binding>> CreateNamespacedPodBindingAsyncWithHttpInfo (string name, string _namespace, V1Binding body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create eviction of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1Eviction</returns>
        System.Threading.Tasks.Task<V1beta1Eviction> CreateNamespacedPodEvictionAsync (string name, string _namespace, V1beta1Eviction body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create eviction of a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1Eviction)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1Eviction>> CreateNamespacedPodEvictionAsyncWithHttpInfo (string name, string _namespace, V1beta1Eviction body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        System.Threading.Tasks.Task<V1PodTemplate> CreateNamespacedPodTemplateAsync (string _namespace, V1PodTemplate body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> CreateNamespacedPodTemplateAsyncWithHttpInfo (string _namespace, V1PodTemplate body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> CreateNamespacedReplicationControllerAsync (string _namespace, V1ReplicationController body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> CreateNamespacedReplicationControllerAsyncWithHttpInfo (string _namespace, V1ReplicationController body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> CreateNamespacedResourceQuotaAsync (string _namespace, V1ResourceQuota body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> CreateNamespacedResourceQuotaAsyncWithHttpInfo (string _namespace, V1ResourceQuota body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        System.Threading.Tasks.Task<V1Secret> CreateNamespacedSecretAsync (string _namespace, V1Secret body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Secret>> CreateNamespacedSecretAsyncWithHttpInfo (string _namespace, V1Secret body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> CreateNamespacedServiceAsync (string _namespace, V1Service body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> CreateNamespacedServiceAsyncWithHttpInfo (string _namespace, V1Service body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        System.Threading.Tasks.Task<V1ServiceAccount> CreateNamespacedServiceAccountAsync (string _namespace, V1ServiceAccount body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> CreateNamespacedServiceAccountAsyncWithHttpInfo (string _namespace, V1ServiceAccount body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> CreateNodeAsync (V1Node body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> CreateNodeAsyncWithHttpInfo (V1Node body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> CreatePersistentVolumeAsync (V1PersistentVolume body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> CreatePersistentVolumeAsyncWithHttpInfo (V1PersistentVolume body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedConfigMapAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedConfigMapAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedEndpointsAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedEndpointsAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedEventAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedEventAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedLimitRangeAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedLimitRangeAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPersistentVolumeClaimAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPodAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPodAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPodTemplateAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPodTemplateAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedReplicationControllerAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedReplicationControllerAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedResourceQuotaAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedResourceQuotaAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedSecretAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedSecretAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedServiceAccountAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedServiceAccountAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNodeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNodeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionPersistentVolumeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionPersistentVolumeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespaceAsync (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespaceAsyncWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedConfigMapAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedEndpointsAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedEventAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete an Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedEventAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedLimitRangeAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedPersistentVolumeClaimAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedPodAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPodAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedPodTemplateAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedReplicationControllerAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedResourceQuotaAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedSecretAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedServiceAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedServiceAccountAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNodeAsync (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNodeAsyncWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeletePersistentVolumeAsync (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeletePersistentVolumeAsyncWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of V1APIResourceList</returns>
        System.Threading.Tasks.Task<V1APIResourceList> GetAPIResourcesAsync ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (V1APIResourceList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1APIResourceList>> GetAPIResourcesAsyncWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list objects of kind ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ComponentStatusList</returns>
        System.Threading.Tasks.Task<V1ComponentStatusList> ListComponentStatusAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list objects of kind ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ComponentStatusList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ComponentStatusList>> ListComponentStatusAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ConfigMapList</returns>
        System.Threading.Tasks.Task<V1ConfigMapList> ListConfigMapForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMapList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ConfigMapList>> ListConfigMapForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EndpointsList</returns>
        System.Threading.Tasks.Task<V1EndpointsList> ListEndpointsForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EndpointsList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1EndpointsList>> ListEndpointsForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EventList</returns>
        System.Threading.Tasks.Task<V1EventList> ListEventForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EventList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1EventList>> ListEventForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1LimitRangeList</returns>
        System.Threading.Tasks.Task<V1LimitRangeList> ListLimitRangeForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRangeList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1LimitRangeList>> ListLimitRangeForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1NamespaceList</returns>
        System.Threading.Tasks.Task<V1NamespaceList> ListNamespaceAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1NamespaceList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1NamespaceList>> ListNamespaceAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ConfigMapList</returns>
        System.Threading.Tasks.Task<V1ConfigMapList> ListNamespacedConfigMapAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMapList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ConfigMapList>> ListNamespacedConfigMapAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EndpointsList</returns>
        System.Threading.Tasks.Task<V1EndpointsList> ListNamespacedEndpointsAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EndpointsList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1EndpointsList>> ListNamespacedEndpointsAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EventList</returns>
        System.Threading.Tasks.Task<V1EventList> ListNamespacedEventAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EventList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1EventList>> ListNamespacedEventAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1LimitRangeList</returns>
        System.Threading.Tasks.Task<V1LimitRangeList> ListNamespacedLimitRangeAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRangeList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1LimitRangeList>> ListNamespacedLimitRangeAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaimList</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaimList> ListNamespacedPersistentVolumeClaimAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaimList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaimList>> ListNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodList</returns>
        System.Threading.Tasks.Task<V1PodList> ListNamespacedPodAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodList>> ListNamespacedPodAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodTemplateList</returns>
        System.Threading.Tasks.Task<V1PodTemplateList> ListNamespacedPodTemplateAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplateList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodTemplateList>> ListNamespacedPodTemplateAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ReplicationControllerList</returns>
        System.Threading.Tasks.Task<V1ReplicationControllerList> ListNamespacedReplicationControllerAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationControllerList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationControllerList>> ListNamespacedReplicationControllerAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ResourceQuotaList</returns>
        System.Threading.Tasks.Task<V1ResourceQuotaList> ListNamespacedResourceQuotaAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuotaList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuotaList>> ListNamespacedResourceQuotaAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1SecretList</returns>
        System.Threading.Tasks.Task<V1SecretList> ListNamespacedSecretAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1SecretList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1SecretList>> ListNamespacedSecretAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceList</returns>
        System.Threading.Tasks.Task<V1ServiceList> ListNamespacedServiceAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceList>> ListNamespacedServiceAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceAccountList</returns>
        System.Threading.Tasks.Task<V1ServiceAccountList> ListNamespacedServiceAccountAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccountList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceAccountList>> ListNamespacedServiceAccountAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1NodeList</returns>
        System.Threading.Tasks.Task<V1NodeList> ListNodeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1NodeList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1NodeList>> ListNodeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PersistentVolumeList</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeList> ListPersistentVolumeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeList>> ListPersistentVolumeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaimList</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaimList> ListPersistentVolumeClaimForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaimList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaimList>> ListPersistentVolumeClaimForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodList</returns>
        System.Threading.Tasks.Task<V1PodList> ListPodForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodList>> ListPodForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodTemplateList</returns>
        System.Threading.Tasks.Task<V1PodTemplateList> ListPodTemplateForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplateList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodTemplateList>> ListPodTemplateForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ReplicationControllerList</returns>
        System.Threading.Tasks.Task<V1ReplicationControllerList> ListReplicationControllerForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationControllerList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationControllerList>> ListReplicationControllerForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ResourceQuotaList</returns>
        System.Threading.Tasks.Task<V1ResourceQuotaList> ListResourceQuotaForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuotaList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuotaList>> ListResourceQuotaForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1SecretList</returns>
        System.Threading.Tasks.Task<V1SecretList> ListSecretForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1SecretList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1SecretList>> ListSecretForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceAccountList</returns>
        System.Threading.Tasks.Task<V1ServiceAccountList> ListServiceAccountForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccountList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceAccountList>> ListServiceAccountForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceList</returns>
        System.Threading.Tasks.Task<V1ServiceList> ListServiceForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceList>> ListServiceForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> PatchNamespaceAsync (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> PatchNamespaceAsyncWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> PatchNamespaceStatusAsync (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> PatchNamespaceStatusAsyncWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        System.Threading.Tasks.Task<V1ConfigMap> PatchNamespacedConfigMapAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> PatchNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        System.Threading.Tasks.Task<V1Endpoints> PatchNamespacedEndpointsAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> PatchNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Event</returns>
        System.Threading.Tasks.Task<V1Event> PatchNamespacedEventAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Event>> PatchNamespacedEventAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        System.Threading.Tasks.Task<V1LimitRange> PatchNamespacedLimitRangeAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> PatchNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimStatusAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> PatchNamespacedPodAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> PatchNamespacedPodAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> PatchNamespacedPodStatusAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> PatchNamespacedPodStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        System.Threading.Tasks.Task<V1PodTemplate> PatchNamespacedPodTemplateAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> PatchNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> PatchNamespacedReplicationControllerAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> PatchNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Scale</returns>
        System.Threading.Tasks.Task<V1Scale> PatchNamespacedReplicationControllerScaleAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Scale)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Scale>> PatchNamespacedReplicationControllerScaleAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> PatchNamespacedReplicationControllerStatusAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> PatchNamespacedReplicationControllerStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> PatchNamespacedResourceQuotaAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> PatchNamespacedResourceQuotaStatusAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        System.Threading.Tasks.Task<V1Secret> PatchNamespacedSecretAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Secret>> PatchNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> PatchNamespacedServiceAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> PatchNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        System.Threading.Tasks.Task<V1ServiceAccount> PatchNamespacedServiceAccountAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> PatchNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> PatchNamespacedServiceStatusAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> PatchNamespacedServiceStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> PatchNodeAsync (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> PatchNodeAsyncWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> PatchNodeStatusAsync (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> PatchNodeStatusAsyncWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> PatchPersistentVolumeAsync (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> PatchPersistentVolumeAsyncWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> PatchPersistentVolumeStatusAsync (string name, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> PatchPersistentVolumeStatusAsyncWithHttpInfo (string name, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyDELETENamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyDELETENamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyDELETENamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyDELETENamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyDELETENodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyDELETENodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy DELETE requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyGETNamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyGETNamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyGETNamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyGETNamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyGETNodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyGETNodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy GET requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyHEADNamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyHEADNamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyHEADNamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyHEADNamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyHEADNodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyHEADNodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy HEAD requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyOPTIONSNodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyOPTIONSNodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy OPTIONS requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPATCHNamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPATCHNamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPATCHNamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPATCHNamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPATCHNodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPATCHNodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PATCH requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPOSTNamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPOSTNamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPOSTNamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPOSTNamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPOSTNodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPOSTNodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy POST requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPUTNamespacedPodAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedPodAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPUTNamespacedPodWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPUTNamespacedServiceAsync (string name, string _namespace);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedServiceAsyncWithHttpInfo (string name, string _namespace);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPUTNamespacedServiceWithPathAsync (string name, string _namespace, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPUTNodeAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNodeAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ProxyPUTNodeWithPathAsync (string name, string path);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// proxy PUT requests to Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNodeWithPathAsyncWithHttpInfo (string name, string path);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ComponentStatus</returns>
        System.Threading.Tasks.Task<V1ComponentStatus> ReadComponentStatusAsync (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ComponentStatus
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ComponentStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ComponentStatus>> ReadComponentStatusAsyncWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> ReadNamespaceAsync (string name, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReadNamespaceAsyncWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> ReadNamespaceStatusAsync (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReadNamespaceStatusAsyncWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        System.Threading.Tasks.Task<V1ConfigMap> ReadNamespacedConfigMapAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> ReadNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        System.Threading.Tasks.Task<V1Endpoints> ReadNamespacedEndpointsAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> ReadNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Event</returns>
        System.Threading.Tasks.Task<V1Event> ReadNamespacedEventAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Event>> ReadNamespacedEventAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        System.Threading.Tasks.Task<V1LimitRange> ReadNamespacedLimitRangeAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> ReadNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimStatusAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> ReadNamespacedPodAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReadNamespacedPodAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read log of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ReadNamespacedPodLogAsync (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read log of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ReadNamespacedPodLogAsyncWithHttpInfo (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> ReadNamespacedPodStatusAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReadNamespacedPodStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        System.Threading.Tasks.Task<V1PodTemplate> ReadNamespacedPodTemplateAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> ReadNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> ReadNamespacedReplicationControllerAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReadNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Scale</returns>
        System.Threading.Tasks.Task<V1Scale> ReadNamespacedReplicationControllerScaleAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Scale)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Scale>> ReadNamespacedReplicationControllerScaleAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> ReadNamespacedReplicationControllerStatusAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReadNamespacedReplicationControllerStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> ReadNamespacedResourceQuotaAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> ReadNamespacedResourceQuotaStatusAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        System.Threading.Tasks.Task<V1Secret> ReadNamespacedSecretAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Secret>> ReadNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> ReadNamespacedServiceAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> ReadNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        System.Threading.Tasks.Task<V1ServiceAccount> ReadNamespacedServiceAccountAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> ReadNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> ReadNamespacedServiceStatusAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> ReadNamespacedServiceStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> ReadNodeAsync (string name, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> ReadNodeAsyncWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> ReadNodeStatusAsync (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> ReadNodeStatusAsyncWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> ReadPersistentVolumeAsync (string name, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReadPersistentVolumeAsyncWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> ReadPersistentVolumeStatusAsync (string name, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReadPersistentVolumeStatusAsyncWithHttpInfo (string name, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> ReplaceNamespaceAsync (string name, V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReplaceNamespaceAsyncWithHttpInfo (string name, V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace finalize of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> ReplaceNamespaceFinalizeAsync (string name, V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace finalize of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReplaceNamespaceFinalizeAsyncWithHttpInfo (string name, V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        System.Threading.Tasks.Task<V1Namespace> ReplaceNamespaceStatusAsync (string name, V1Namespace body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Namespace
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReplaceNamespaceStatusAsyncWithHttpInfo (string name, V1Namespace body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        System.Threading.Tasks.Task<V1ConfigMap> ReplaceNamespacedConfigMapAsync (string name, string _namespace, V1ConfigMap body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ConfigMap
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> ReplaceNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, V1ConfigMap body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        System.Threading.Tasks.Task<V1Endpoints> ReplaceNamespacedEndpointsAsync (string name, string _namespace, V1Endpoints body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Endpoints
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> ReplaceNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, V1Endpoints body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Event</returns>
        System.Threading.Tasks.Task<V1Event> ReplaceNamespacedEventAsync (string name, string _namespace, V1Event body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Event
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Event>> ReplaceNamespacedEventAsyncWithHttpInfo (string name, string _namespace, V1Event body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        System.Threading.Tasks.Task<V1LimitRange> ReplaceNamespacedLimitRangeAsync (string name, string _namespace, V1LimitRange body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified LimitRange
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> ReplaceNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, V1LimitRange body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimAsync (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimStatusAsync (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolumeClaim
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> ReplaceNamespacedPodAsync (string name, string _namespace, V1Pod body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReplaceNamespacedPodAsyncWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        System.Threading.Tasks.Task<V1Pod> ReplaceNamespacedPodStatusAsync (string name, string _namespace, V1Pod body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Pod
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReplaceNamespacedPodStatusAsyncWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        System.Threading.Tasks.Task<V1PodTemplate> ReplaceNamespacedPodTemplateAsync (string name, string _namespace, V1PodTemplate body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodTemplate
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> ReplaceNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, V1PodTemplate body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> ReplaceNamespacedReplicationControllerAsync (string name, string _namespace, V1ReplicationController body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Scale</returns>
        System.Threading.Tasks.Task<V1Scale> ReplaceNamespacedReplicationControllerScaleAsync (string name, string _namespace, V1Scale body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace scale of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Scale)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Scale>> ReplaceNamespacedReplicationControllerScaleAsyncWithHttpInfo (string name, string _namespace, V1Scale body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        System.Threading.Tasks.Task<V1ReplicationController> ReplaceNamespacedReplicationControllerStatusAsync (string name, string _namespace, V1ReplicationController body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ReplicationController
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerStatusAsyncWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> ReplaceNamespacedResourceQuotaAsync (string name, string _namespace, V1ResourceQuota body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        System.Threading.Tasks.Task<V1ResourceQuota> ReplaceNamespacedResourceQuotaStatusAsync (string name, string _namespace, V1ResourceQuota body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified ResourceQuota
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaStatusAsyncWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        System.Threading.Tasks.Task<V1Secret> ReplaceNamespacedSecretAsync (string name, string _namespace, V1Secret body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Secret
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Secret>> ReplaceNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, V1Secret body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> ReplaceNamespacedServiceAsync (string name, string _namespace, V1Service body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> ReplaceNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        System.Threading.Tasks.Task<V1ServiceAccount> ReplaceNamespacedServiceAccountAsync (string name, string _namespace, V1ServiceAccount body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified ServiceAccount
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> ReplaceNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, V1ServiceAccount body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        System.Threading.Tasks.Task<V1Service> ReplaceNamespacedServiceStatusAsync (string name, string _namespace, V1Service body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Service
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Service>> ReplaceNamespacedServiceStatusAsyncWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> ReplaceNodeAsync (string name, V1Node body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> ReplaceNodeAsyncWithHttpInfo (string name, V1Node body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        System.Threading.Tasks.Task<V1Node> ReplaceNodeStatusAsync (string name, V1Node body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified Node
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Node>> ReplaceNodeStatusAsyncWithHttpInfo (string name, V1Node body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> ReplacePersistentVolumeAsync (string name, V1PersistentVolume body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReplacePersistentVolumeAsyncWithHttpInfo (string name, V1PersistentVolume body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        System.Threading.Tasks.Task<V1PersistentVolume> ReplacePersistentVolumeStatusAsync (string name, V1PersistentVolume body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PersistentVolume
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReplacePersistentVolumeStatusAsyncWithHttpInfo (string name, V1PersistentVolume body, string pretty = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Core_v1Api : ICore_v1Api
    {
        private Kubernetes.DotNet.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="Core_v1Api"/> class.
        /// </summary>
        /// <returns></returns>
        public Core_v1Api(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Kubernetes.DotNet.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Core_v1Api"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public Core_v1Api(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Kubernetes.DotNet.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Kubernetes.DotNet.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectDeleteNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectDeleteNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectDeleteNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectDeleteNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectDeleteNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectDeleteNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectDeleteNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectDeleteNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectDeleteNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectDeleteNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectDeleteNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect DELETE requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectDeleteNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectDeleteNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectDeleteNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectDeleteNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectDeleteNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectDeleteNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectDeleteNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectDeleteNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectDeleteNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectDeleteNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectDeleteNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect DELETE requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectDeleteNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectDeleteNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectDeleteNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectDeleteNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectDeleteNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectDeleteNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectDeleteNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectDeleteNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectDeleteNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectDeleteNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectDeleteNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectDeleteNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect DELETE requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectDeleteNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectDeleteNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectDeleteNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectDeleteNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedPodAttach (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedPodAttachWithHttpInfo(name, _namespace, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedPodAttachWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodAttach");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodAttach");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/attach";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodAttach", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedPodAttachAsync (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedPodAttachAsyncWithHttpInfo(name, _namespace, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodAttachAsyncWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodAttach");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodAttach");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/attach";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodAttach", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedPodExec (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedPodExecWithHttpInfo(name, _namespace, command, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedPodExecWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodExec");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodExec");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/exec";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (command != null) localVarQueryParams.Add("command", Configuration.ApiClient.ParameterToString(command)); // query parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodExec", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedPodExecAsync (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedPodExecAsyncWithHttpInfo(name, _namespace, command, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodExecAsyncWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodExec");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodExec");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/exec";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (command != null) localVarQueryParams.Add("command", Configuration.ApiClient.ParameterToString(command)); // query parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodExec", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedPodPortforward (string name, string _namespace, int? ports = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedPodPortforwardWithHttpInfo(name, _namespace, ports);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedPodPortforwardWithHttpInfo (string name, string _namespace, int? ports = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodPortforward");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodPortforward");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/portforward";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (ports != null) localVarQueryParams.Add("ports", Configuration.ApiClient.ParameterToString(ports)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodPortforward", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedPodPortforwardAsync (string name, string _namespace, int? ports = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedPodPortforwardAsyncWithHttpInfo(name, _namespace, ports);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodPortforwardAsyncWithHttpInfo (string name, string _namespace, int? ports = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodPortforward");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodPortforward");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/portforward";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (ports != null) localVarQueryParams.Add("ports", Configuration.ApiClient.ParameterToString(ports)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodPortforward", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectGetNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectGetNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectGetNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectGetNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectGetNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectGetNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectGetNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectGetNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectGetNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectGetNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectGetNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect GET requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectGetNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectGetNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectGetNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectGetNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectHeadNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectHeadNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectHeadNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectHeadNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectHeadNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectHeadNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectHeadNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectHeadNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectHeadNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectHeadNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectHeadNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect HEAD requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectHeadNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectHeadNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectHeadNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectHeadNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectHeadNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectHeadNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectHeadNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectHeadNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectHeadNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectHeadNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectHeadNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectHeadNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect HEAD requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectHeadNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectHeadNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectHeadNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectHeadNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectHeadNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectHeadNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectHeadNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectHeadNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectHeadNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectHeadNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectHeadNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectHeadNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectHeadNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect HEAD requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectHeadNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectHeadNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectHeadNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectHeadNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectOptionsNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectOptionsNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectOptionsNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectOptionsNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectOptionsNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectOptionsNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectOptionsNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectOptionsNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectOptionsNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectOptionsNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectOptionsNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectOptionsNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectOptionsNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectOptionsNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectOptionsNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectOptionsNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectOptionsNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectOptionsNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectOptionsNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectOptionsNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectOptionsNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectOptionsNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectOptionsNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectOptionsNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectOptionsNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectOptionsNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectOptionsNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectOptionsNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectOptionsNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectOptionsNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectOptionsNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectOptionsNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectOptionsNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectOptionsNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect OPTIONS requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectOptionsNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectOptionsNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectOptionsNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectOptionsNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPatchNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPatchNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPatchNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPatchNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPatchNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPatchNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPatchNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPatchNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPatchNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPatchNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPatchNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PATCH requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPatchNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPatchNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPatchNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPatchNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPatchNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPatchNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPatchNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPatchNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPatchNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPatchNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPatchNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPatchNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PATCH requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPatchNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPatchNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPatchNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPatchNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPatchNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPatchNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPatchNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPatchNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPatchNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPatchNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPatchNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPatchNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPatchNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PATCH requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPatchNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPatchNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPatchNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPatchNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedPodAttach (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedPodAttachWithHttpInfo(name, _namespace, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedPodAttachWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodAttach");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodAttach");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/attach";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodAttach", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedPodAttachAsync (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedPodAttachAsyncWithHttpInfo(name, _namespace, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to attach of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="stdin">Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodAttachAsyncWithHttpInfo (string name, string _namespace, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodAttach");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodAttach");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/attach";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodAttach", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedPodExec (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedPodExecWithHttpInfo(name, _namespace, command, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedPodExecWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodExec");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodExec");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/exec";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (command != null) localVarQueryParams.Add("command", Configuration.ApiClient.ParameterToString(command)); // query parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodExec", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedPodExecAsync (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedPodExecAsyncWithHttpInfo(name, _namespace, command, container, stderr, stdin, stdout, tty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to exec of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="command">Command is the remote command to execute. argv array. Not executed within a shell. (optional)</param>
        /// <param name="container">Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)</param>
        /// <param name="stderr">Redirect the standard error stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="stdin">Redirect the standard input stream of the pod for this call. Defaults to false. (optional)</param>
        /// <param name="stdout">Redirect the standard output stream of the pod for this call. Defaults to true. (optional)</param>
        /// <param name="tty">TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodExecAsyncWithHttpInfo (string name, string _namespace, string command = null, string container = null, bool? stderr = null, bool? stdin = null, bool? stdout = null, bool? tty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodExec");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodExec");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/exec";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (command != null) localVarQueryParams.Add("command", Configuration.ApiClient.ParameterToString(command)); // query parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (stderr != null) localVarQueryParams.Add("stderr", Configuration.ApiClient.ParameterToString(stderr)); // query parameter
            if (stdin != null) localVarQueryParams.Add("stdin", Configuration.ApiClient.ParameterToString(stdin)); // query parameter
            if (stdout != null) localVarQueryParams.Add("stdout", Configuration.ApiClient.ParameterToString(stdout)); // query parameter
            if (tty != null) localVarQueryParams.Add("tty", Configuration.ApiClient.ParameterToString(tty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodExec", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedPodPortforward (string name, string _namespace, int? ports = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedPodPortforwardWithHttpInfo(name, _namespace, ports);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedPodPortforwardWithHttpInfo (string name, string _namespace, int? ports = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodPortforward");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodPortforward");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/portforward";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (ports != null) localVarQueryParams.Add("ports", Configuration.ApiClient.ParameterToString(ports)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodPortforward", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedPodPortforwardAsync (string name, string _namespace, int? ports = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedPodPortforwardAsyncWithHttpInfo(name, _namespace, ports);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to portforward of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="ports">List of ports to forward Required when using WebSockets (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodPortforwardAsyncWithHttpInfo (string name, string _namespace, int? ports = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodPortforward");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodPortforward");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/portforward";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (ports != null) localVarQueryParams.Add("ports", Configuration.ApiClient.ParameterToString(ports)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodPortforward", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPostNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPostNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPostNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPostNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPostNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPostNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPostNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPostNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPostNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPostNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPostNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect POST requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPostNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPostNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPostNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPostNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPutNamespacedPodProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPutNamespacedPodProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPutNamespacedPodProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPutNamespacedPodProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPutNamespacedPodProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedPodProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedPodProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedPodProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedPodProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPutNamespacedPodProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPutNamespacedPodProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPutNamespacedPodProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPutNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPutNamespacedPodProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPutNamespacedPodProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PUT requests to proxy of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to pod. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedPodProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedPodProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedPodProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPutNamespacedPodProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedPodProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPutNamespacedServiceProxy (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPutNamespacedServiceProxyWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPutNamespacedServiceProxyWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPutNamespacedServiceProxyAsync (string name, string _namespace, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPutNamespacedServiceProxyAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedServiceProxyAsyncWithHttpInfo (string name, string _namespace, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedServiceProxy");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedServiceProxy");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedServiceProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPutNamespacedServiceProxyWithPath (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPutNamespacedServiceProxyWithPathWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPutNamespacedServiceProxyWithPathWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPutNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPutNamespacedServiceProxyWithPathAsync (string name, string _namespace, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPutNamespacedServiceProxyWithPathAsyncWithHttpInfo(name, _namespace, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PUT requests to proxy of Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNamespacedServiceProxyWithPathAsyncWithHttpInfo (string name, string _namespace, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNamespacedServiceProxyWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ConnectPutNamespacedServiceProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPutNamespacedServiceProxyWithPath");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNamespacedServiceProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPutNodeProxy (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = ConnectPutNodeProxyWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPutNodeProxyWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPutNodeProxyAsync (string name, string path = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPutNodeProxyAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNodeProxyAsyncWithHttpInfo (string name, string path = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNodeProxy");

            var localVarPath = "/api/v1/nodes/{name}/proxy";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNodeProxy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>string</returns>
        public string ConnectPutNodeProxyWithPath (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = ConnectPutNodeProxyWithPathWithHttpInfo(name, path, path2);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ConnectPutNodeProxyWithPathWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPutNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ConnectPutNodeProxyWithPathAsync (string name, string path, string path2 = null)
        {
             ApiResponse<string> localVarResponse = await ConnectPutNodeProxyWithPathAsyncWithHttpInfo(name, path, path2);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  connect PUT requests to proxy of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <param name="path2">Path is the URL path to use for the current proxy request to node. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ConnectPutNodeProxyWithPathAsyncWithHttpInfo (string name, string path, string path2 = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ConnectPutNodeProxyWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ConnectPutNodeProxyWithPath");

            var localVarPath = "/api/v1/nodes/{name}/proxy/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter
            if (path2 != null) localVarQueryParams.Add("path", Configuration.ApiClient.ParameterToString(path2)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ConnectPutNodeProxyWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  create a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace CreateNamespace (V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = CreateNamespaceWithHttpInfo(body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > CreateNamespaceWithHttpInfo (V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespace");

            var localVarPath = "/api/v1/namespaces";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  create a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> CreateNamespaceAsync (V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await CreateNamespaceAsyncWithHttpInfo(body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> CreateNamespaceAsyncWithHttpInfo (V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespace");

            var localVarPath = "/api/v1/namespaces";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  create a Binding
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Binding</returns>
        public V1Binding CreateNamespacedBinding (string _namespace, V1Binding body, string pretty = null)
        {
             ApiResponse<V1Binding> localVarResponse = CreateNamespacedBindingWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a Binding
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Binding</returns>
        public ApiResponse< V1Binding > CreateNamespacedBindingWithHttpInfo (string _namespace, V1Binding body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedBinding");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedBinding");

            var localVarPath = "/api/v1/namespaces/{namespace}/bindings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedBinding", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Binding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Binding) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Binding)));
        }

        /// <summary>
        ///  create a Binding
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Binding</returns>
        public async System.Threading.Tasks.Task<V1Binding> CreateNamespacedBindingAsync (string _namespace, V1Binding body, string pretty = null)
        {
             ApiResponse<V1Binding> localVarResponse = await CreateNamespacedBindingAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a Binding
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Binding)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Binding>> CreateNamespacedBindingAsyncWithHttpInfo (string _namespace, V1Binding body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedBinding");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedBinding");

            var localVarPath = "/api/v1/namespaces/{namespace}/bindings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedBinding", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Binding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Binding) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Binding)));
        }

        /// <summary>
        ///  create a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        public V1ConfigMap CreateNamespacedConfigMap (string _namespace, V1ConfigMap body, string pretty = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = CreateNamespacedConfigMapWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        public ApiResponse< V1ConfigMap > CreateNamespacedConfigMapWithHttpInfo (string _namespace, V1ConfigMap body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  create a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        public async System.Threading.Tasks.Task<V1ConfigMap> CreateNamespacedConfigMapAsync (string _namespace, V1ConfigMap body, string pretty = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = await CreateNamespacedConfigMapAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> CreateNamespacedConfigMapAsyncWithHttpInfo (string _namespace, V1ConfigMap body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  create Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Endpoints</returns>
        public V1Endpoints CreateNamespacedEndpoints (string _namespace, V1Endpoints body, string pretty = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = CreateNamespacedEndpointsWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        public ApiResponse< V1Endpoints > CreateNamespacedEndpointsWithHttpInfo (string _namespace, V1Endpoints body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  create Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        public async System.Threading.Tasks.Task<V1Endpoints> CreateNamespacedEndpointsAsync (string _namespace, V1Endpoints body, string pretty = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = await CreateNamespacedEndpointsAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> CreateNamespacedEndpointsAsyncWithHttpInfo (string _namespace, V1Endpoints body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  create an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Event</returns>
        public V1Event CreateNamespacedEvent (string _namespace, V1Event body, string pretty = null)
        {
             ApiResponse<V1Event> localVarResponse = CreateNamespacedEventWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        public ApiResponse< V1Event > CreateNamespacedEventWithHttpInfo (string _namespace, V1Event body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  create an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Event</returns>
        public async System.Threading.Tasks.Task<V1Event> CreateNamespacedEventAsync (string _namespace, V1Event body, string pretty = null)
        {
             ApiResponse<V1Event> localVarResponse = await CreateNamespacedEventAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Event>> CreateNamespacedEventAsyncWithHttpInfo (string _namespace, V1Event body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  create a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1LimitRange</returns>
        public V1LimitRange CreateNamespacedLimitRange (string _namespace, V1LimitRange body, string pretty = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = CreateNamespacedLimitRangeWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        public ApiResponse< V1LimitRange > CreateNamespacedLimitRangeWithHttpInfo (string _namespace, V1LimitRange body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  create a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        public async System.Threading.Tasks.Task<V1LimitRange> CreateNamespacedLimitRangeAsync (string _namespace, V1LimitRange body, string pretty = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = await CreateNamespacedLimitRangeAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> CreateNamespacedLimitRangeAsyncWithHttpInfo (string _namespace, V1LimitRange body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  create a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim CreateNamespacedPersistentVolumeClaim (string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = CreateNamespacedPersistentVolumeClaimWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > CreateNamespacedPersistentVolumeClaimWithHttpInfo (string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  create a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> CreateNamespacedPersistentVolumeClaimAsync (string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await CreateNamespacedPersistentVolumeClaimAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> CreateNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  create a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod CreateNamespacedPod (string _namespace, V1Pod body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = CreateNamespacedPodWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > CreateNamespacedPodWithHttpInfo (string _namespace, V1Pod body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  create a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> CreateNamespacedPodAsync (string _namespace, V1Pod body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = await CreateNamespacedPodAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> CreateNamespacedPodAsyncWithHttpInfo (string _namespace, V1Pod body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  create binding of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Binding</returns>
        public V1Binding CreateNamespacedPodBinding (string name, string _namespace, V1Binding body, string pretty = null)
        {
             ApiResponse<V1Binding> localVarResponse = CreateNamespacedPodBindingWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create binding of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Binding</returns>
        public ApiResponse< V1Binding > CreateNamespacedPodBindingWithHttpInfo (string name, string _namespace, V1Binding body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->CreateNamespacedPodBinding");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPodBinding");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPodBinding");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/binding";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodBinding", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Binding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Binding) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Binding)));
        }

        /// <summary>
        ///  create binding of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Binding</returns>
        public async System.Threading.Tasks.Task<V1Binding> CreateNamespacedPodBindingAsync (string name, string _namespace, V1Binding body, string pretty = null)
        {
             ApiResponse<V1Binding> localVarResponse = await CreateNamespacedPodBindingAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create binding of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Binding</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Binding)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Binding>> CreateNamespacedPodBindingAsyncWithHttpInfo (string name, string _namespace, V1Binding body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->CreateNamespacedPodBinding");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPodBinding");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPodBinding");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/binding";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodBinding", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Binding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Binding) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Binding)));
        }

        /// <summary>
        ///  create eviction of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1Eviction</returns>
        public V1beta1Eviction CreateNamespacedPodEviction (string name, string _namespace, V1beta1Eviction body, string pretty = null)
        {
             ApiResponse<V1beta1Eviction> localVarResponse = CreateNamespacedPodEvictionWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create eviction of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1Eviction</returns>
        public ApiResponse< V1beta1Eviction > CreateNamespacedPodEvictionWithHttpInfo (string name, string _namespace, V1beta1Eviction body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->CreateNamespacedPodEviction");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPodEviction");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPodEviction");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/eviction";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodEviction", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1Eviction>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1Eviction) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1Eviction)));
        }

        /// <summary>
        ///  create eviction of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1Eviction</returns>
        public async System.Threading.Tasks.Task<V1beta1Eviction> CreateNamespacedPodEvictionAsync (string name, string _namespace, V1beta1Eviction body, string pretty = null)
        {
             ApiResponse<V1beta1Eviction> localVarResponse = await CreateNamespacedPodEvictionAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create eviction of a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Eviction</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1Eviction)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1Eviction>> CreateNamespacedPodEvictionAsyncWithHttpInfo (string name, string _namespace, V1beta1Eviction body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->CreateNamespacedPodEviction");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPodEviction");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPodEviction");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/eviction";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodEviction", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1Eviction>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1Eviction) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1Eviction)));
        }

        /// <summary>
        ///  create a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        public V1PodTemplate CreateNamespacedPodTemplate (string _namespace, V1PodTemplate body, string pretty = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = CreateNamespacedPodTemplateWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        public ApiResponse< V1PodTemplate > CreateNamespacedPodTemplateWithHttpInfo (string _namespace, V1PodTemplate body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  create a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        public async System.Threading.Tasks.Task<V1PodTemplate> CreateNamespacedPodTemplateAsync (string _namespace, V1PodTemplate body, string pretty = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = await CreateNamespacedPodTemplateAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> CreateNamespacedPodTemplateAsyncWithHttpInfo (string _namespace, V1PodTemplate body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  create a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController CreateNamespacedReplicationController (string _namespace, V1ReplicationController body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = CreateNamespacedReplicationControllerWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > CreateNamespacedReplicationControllerWithHttpInfo (string _namespace, V1ReplicationController body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  create a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> CreateNamespacedReplicationControllerAsync (string _namespace, V1ReplicationController body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await CreateNamespacedReplicationControllerAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> CreateNamespacedReplicationControllerAsyncWithHttpInfo (string _namespace, V1ReplicationController body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  create a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota CreateNamespacedResourceQuota (string _namespace, V1ResourceQuota body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = CreateNamespacedResourceQuotaWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > CreateNamespacedResourceQuotaWithHttpInfo (string _namespace, V1ResourceQuota body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  create a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> CreateNamespacedResourceQuotaAsync (string _namespace, V1ResourceQuota body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await CreateNamespacedResourceQuotaAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> CreateNamespacedResourceQuotaAsyncWithHttpInfo (string _namespace, V1ResourceQuota body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  create a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Secret</returns>
        public V1Secret CreateNamespacedSecret (string _namespace, V1Secret body, string pretty = null)
        {
             ApiResponse<V1Secret> localVarResponse = CreateNamespacedSecretWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        public ApiResponse< V1Secret > CreateNamespacedSecretWithHttpInfo (string _namespace, V1Secret body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  create a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        public async System.Threading.Tasks.Task<V1Secret> CreateNamespacedSecretAsync (string _namespace, V1Secret body, string pretty = null)
        {
             ApiResponse<V1Secret> localVarResponse = await CreateNamespacedSecretAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Secret>> CreateNamespacedSecretAsyncWithHttpInfo (string _namespace, V1Secret body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  create a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service CreateNamespacedService (string _namespace, V1Service body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = CreateNamespacedServiceWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > CreateNamespacedServiceWithHttpInfo (string _namespace, V1Service body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedService");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  create a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> CreateNamespacedServiceAsync (string _namespace, V1Service body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = await CreateNamespacedServiceAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> CreateNamespacedServiceAsyncWithHttpInfo (string _namespace, V1Service body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedService");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  create a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        public V1ServiceAccount CreateNamespacedServiceAccount (string _namespace, V1ServiceAccount body, string pretty = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = CreateNamespacedServiceAccountWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        public ApiResponse< V1ServiceAccount > CreateNamespacedServiceAccountWithHttpInfo (string _namespace, V1ServiceAccount body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  create a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        public async System.Threading.Tasks.Task<V1ServiceAccount> CreateNamespacedServiceAccountAsync (string _namespace, V1ServiceAccount body, string pretty = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = await CreateNamespacedServiceAccountAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> CreateNamespacedServiceAccountAsyncWithHttpInfo (string _namespace, V1ServiceAccount body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->CreateNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  create a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node CreateNode (V1Node body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = CreateNodeWithHttpInfo(body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > CreateNodeWithHttpInfo (V1Node body, string pretty = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNode");

            var localVarPath = "/api/v1/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  create a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> CreateNodeAsync (V1Node body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = await CreateNodeAsyncWithHttpInfo(body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> CreateNodeAsyncWithHttpInfo (V1Node body, string pretty = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreateNode");

            var localVarPath = "/api/v1/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  create a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume CreatePersistentVolume (V1PersistentVolume body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = CreatePersistentVolumeWithHttpInfo(body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > CreatePersistentVolumeWithHttpInfo (V1PersistentVolume body, string pretty = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreatePersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreatePersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  create a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> CreatePersistentVolumeAsync (V1PersistentVolume body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await CreatePersistentVolumeAsyncWithHttpInfo(body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> CreatePersistentVolumeAsyncWithHttpInfo (V1PersistentVolume body, string pretty = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->CreatePersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreatePersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  delete collection of ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedConfigMap (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedConfigMapWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedConfigMapWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedConfigMapAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedConfigMapAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedConfigMapAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedEndpoints (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedEndpointsWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedEndpointsWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedEndpointsAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedEndpointsAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedEndpointsAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedEvent (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedEventWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedEventWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedEventAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedEventAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedEventAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedLimitRange (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedLimitRangeWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedLimitRangeWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedLimitRangeAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedLimitRangeAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedLimitRangeAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedPersistentVolumeClaim (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPersistentVolumeClaimAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedPersistentVolumeClaimAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedPod (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedPodWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedPodWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPodAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedPodAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPodAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedPodTemplate (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedPodTemplateWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedPodTemplateWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPodTemplateAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedPodTemplateAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPodTemplateAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedReplicationController (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedReplicationControllerWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedReplicationControllerWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedReplicationControllerAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedReplicationControllerAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedReplicationControllerAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedResourceQuota (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedResourceQuotaWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedResourceQuotaWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedResourceQuotaAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedResourceQuotaAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedResourceQuotaAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedSecret (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedSecretWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedSecretWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedSecretAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedSecretAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedSecretAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedServiceAccount (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedServiceAccountWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedServiceAccountWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedServiceAccountAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedServiceAccountAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedServiceAccountAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteCollectionNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNode (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNodeWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNodeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNodeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNodeAsyncWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNodeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionPersistentVolume (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionPersistentVolumeWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionPersistentVolumeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/persistentvolumes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionPersistentVolumeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionPersistentVolumeAsyncWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionPersistentVolumeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/persistentvolumes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespace (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespaceWithHttpInfo(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespaceWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespace");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespaceAsync (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespaceAsyncWithHttpInfo(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespaceAsyncWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespace");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedConfigMap (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedConfigMapWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedConfigMapWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedConfigMapAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedConfigMapAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedEndpoints (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedEndpointsWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedEndpointsWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedEndpointsAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedEndpointsAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedEvent (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedEventWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedEventWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedEventAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedEventAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete an Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedEventAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedLimitRange (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedLimitRangeWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedLimitRangeWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedLimitRangeAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedLimitRangeAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedPersistentVolumeClaim (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedPersistentVolumeClaimWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedPersistentVolumeClaimAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedPersistentVolumeClaimAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedPod (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedPodWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedPodWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedPodAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedPodAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPodAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedPodTemplate (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedPodTemplateWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedPodTemplateWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedPodTemplateAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedPodTemplateAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedReplicationController (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedReplicationControllerWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedReplicationControllerAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedReplicationControllerAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedResourceQuota (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedResourceQuotaWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedResourceQuotaAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedResourceQuotaAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedSecret (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedSecretWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedSecretWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedSecretAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedSecretAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedService (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedServiceWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedServiceWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedServiceAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedServiceAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedServiceAccount (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedServiceAccountWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedServiceAccountWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedServiceAccountAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedServiceAccountAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->DeleteNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNode (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNodeWithHttpInfo(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNodeWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNodeAsync (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNodeAsyncWithHttpInfo(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNodeAsyncWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeleteNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeleteNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeletePersistentVolume (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeletePersistentVolumeWithHttpInfo(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeletePersistentVolumeWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeletePersistentVolume");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeletePersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeletePersistentVolumeAsync (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeletePersistentVolumeAsyncWithHttpInfo(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeletePersistentVolumeAsyncWithHttpInfo (string name, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->DeletePersistentVolume");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->DeletePersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>V1APIResourceList</returns>
        public V1APIResourceList GetAPIResources ()
        {
             ApiResponse<V1APIResourceList> localVarResponse = GetAPIResourcesWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of V1APIResourceList</returns>
        public ApiResponse< V1APIResourceList > GetAPIResourcesWithHttpInfo ()
        {

            var localVarPath = "/api/v1/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/yaml", 
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAPIResources", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1APIResourceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1APIResourceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1APIResourceList)));
        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of V1APIResourceList</returns>
        public async System.Threading.Tasks.Task<V1APIResourceList> GetAPIResourcesAsync ()
        {
             ApiResponse<V1APIResourceList> localVarResponse = await GetAPIResourcesAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (V1APIResourceList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1APIResourceList>> GetAPIResourcesAsyncWithHttpInfo ()
        {

            var localVarPath = "/api/v1/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/yaml", 
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAPIResources", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1APIResourceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1APIResourceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1APIResourceList)));
        }

        /// <summary>
        ///  list objects of kind ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ComponentStatusList</returns>
        public V1ComponentStatusList ListComponentStatus (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ComponentStatusList> localVarResponse = ListComponentStatusWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list objects of kind ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ComponentStatusList</returns>
        public ApiResponse< V1ComponentStatusList > ListComponentStatusWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/componentstatuses";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListComponentStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ComponentStatusList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ComponentStatusList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ComponentStatusList)));
        }

        /// <summary>
        ///  list objects of kind ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ComponentStatusList</returns>
        public async System.Threading.Tasks.Task<V1ComponentStatusList> ListComponentStatusAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ComponentStatusList> localVarResponse = await ListComponentStatusAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list objects of kind ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ComponentStatusList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ComponentStatusList>> ListComponentStatusAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/componentstatuses";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListComponentStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ComponentStatusList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ComponentStatusList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ComponentStatusList)));
        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ConfigMapList</returns>
        public V1ConfigMapList ListConfigMapForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ConfigMapList> localVarResponse = ListConfigMapForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMapList</returns>
        public ApiResponse< V1ConfigMapList > ListConfigMapForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListConfigMapForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMapList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMapList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMapList)));
        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ConfigMapList</returns>
        public async System.Threading.Tasks.Task<V1ConfigMapList> ListConfigMapForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ConfigMapList> localVarResponse = await ListConfigMapForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMapList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ConfigMapList>> ListConfigMapForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListConfigMapForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMapList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMapList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMapList)));
        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EndpointsList</returns>
        public V1EndpointsList ListEndpointsForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EndpointsList> localVarResponse = ListEndpointsForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EndpointsList</returns>
        public ApiResponse< V1EndpointsList > ListEndpointsForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEndpointsForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EndpointsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EndpointsList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EndpointsList)));
        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EndpointsList</returns>
        public async System.Threading.Tasks.Task<V1EndpointsList> ListEndpointsForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EndpointsList> localVarResponse = await ListEndpointsForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EndpointsList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1EndpointsList>> ListEndpointsForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEndpointsForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EndpointsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EndpointsList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EndpointsList)));
        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EventList</returns>
        public V1EventList ListEventForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EventList> localVarResponse = ListEventForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EventList</returns>
        public ApiResponse< V1EventList > ListEventForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEventForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EventList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EventList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EventList)));
        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EventList</returns>
        public async System.Threading.Tasks.Task<V1EventList> ListEventForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EventList> localVarResponse = await ListEventForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EventList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1EventList>> ListEventForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEventForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EventList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EventList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EventList)));
        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1LimitRangeList</returns>
        public V1LimitRangeList ListLimitRangeForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1LimitRangeList> localVarResponse = ListLimitRangeForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1LimitRangeList</returns>
        public ApiResponse< V1LimitRangeList > ListLimitRangeForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListLimitRangeForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRangeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRangeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRangeList)));
        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1LimitRangeList</returns>
        public async System.Threading.Tasks.Task<V1LimitRangeList> ListLimitRangeForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1LimitRangeList> localVarResponse = await ListLimitRangeForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRangeList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1LimitRangeList>> ListLimitRangeForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListLimitRangeForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRangeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRangeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRangeList)));
        }

        /// <summary>
        ///  list or watch objects of kind Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1NamespaceList</returns>
        public V1NamespaceList ListNamespace (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1NamespaceList> localVarResponse = ListNamespaceWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1NamespaceList</returns>
        public ApiResponse< V1NamespaceList > ListNamespaceWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/namespaces";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1NamespaceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1NamespaceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1NamespaceList)));
        }

        /// <summary>
        ///  list or watch objects of kind Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1NamespaceList</returns>
        public async System.Threading.Tasks.Task<V1NamespaceList> ListNamespaceAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1NamespaceList> localVarResponse = await ListNamespaceAsyncWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1NamespaceList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1NamespaceList>> ListNamespaceAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/namespaces";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1NamespaceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1NamespaceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1NamespaceList)));
        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ConfigMapList</returns>
        public V1ConfigMapList ListNamespacedConfigMap (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ConfigMapList> localVarResponse = ListNamespacedConfigMapWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMapList</returns>
        public ApiResponse< V1ConfigMapList > ListNamespacedConfigMapWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMapList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMapList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMapList)));
        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ConfigMapList</returns>
        public async System.Threading.Tasks.Task<V1ConfigMapList> ListNamespacedConfigMapAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ConfigMapList> localVarResponse = await ListNamespacedConfigMapAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMapList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ConfigMapList>> ListNamespacedConfigMapAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMapList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMapList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMapList)));
        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EndpointsList</returns>
        public V1EndpointsList ListNamespacedEndpoints (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EndpointsList> localVarResponse = ListNamespacedEndpointsWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EndpointsList</returns>
        public ApiResponse< V1EndpointsList > ListNamespacedEndpointsWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EndpointsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EndpointsList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EndpointsList)));
        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EndpointsList</returns>
        public async System.Threading.Tasks.Task<V1EndpointsList> ListNamespacedEndpointsAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EndpointsList> localVarResponse = await ListNamespacedEndpointsAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EndpointsList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1EndpointsList>> ListNamespacedEndpointsAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EndpointsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EndpointsList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EndpointsList)));
        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1EventList</returns>
        public V1EventList ListNamespacedEvent (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EventList> localVarResponse = ListNamespacedEventWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1EventList</returns>
        public ApiResponse< V1EventList > ListNamespacedEventWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EventList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EventList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EventList)));
        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1EventList</returns>
        public async System.Threading.Tasks.Task<V1EventList> ListNamespacedEventAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1EventList> localVarResponse = await ListNamespacedEventAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1EventList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1EventList>> ListNamespacedEventAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1EventList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1EventList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1EventList)));
        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1LimitRangeList</returns>
        public V1LimitRangeList ListNamespacedLimitRange (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1LimitRangeList> localVarResponse = ListNamespacedLimitRangeWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1LimitRangeList</returns>
        public ApiResponse< V1LimitRangeList > ListNamespacedLimitRangeWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRangeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRangeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRangeList)));
        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1LimitRangeList</returns>
        public async System.Threading.Tasks.Task<V1LimitRangeList> ListNamespacedLimitRangeAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1LimitRangeList> localVarResponse = await ListNamespacedLimitRangeAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRangeList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1LimitRangeList>> ListNamespacedLimitRangeAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRangeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRangeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRangeList)));
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PersistentVolumeClaimList</returns>
        public V1PersistentVolumeClaimList ListNamespacedPersistentVolumeClaim (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PersistentVolumeClaimList> localVarResponse = ListNamespacedPersistentVolumeClaimWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaimList</returns>
        public ApiResponse< V1PersistentVolumeClaimList > ListNamespacedPersistentVolumeClaimWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaimList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaimList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaimList)));
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaimList</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaimList> ListNamespacedPersistentVolumeClaimAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PersistentVolumeClaimList> localVarResponse = await ListNamespacedPersistentVolumeClaimAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaimList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaimList>> ListNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaimList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaimList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaimList)));
        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodList</returns>
        public V1PodList ListNamespacedPod (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodList> localVarResponse = ListNamespacedPodWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodList</returns>
        public ApiResponse< V1PodList > ListNamespacedPodWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodList)));
        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodList</returns>
        public async System.Threading.Tasks.Task<V1PodList> ListNamespacedPodAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodList> localVarResponse = await ListNamespacedPodAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodList>> ListNamespacedPodAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodTemplateList</returns>
        public V1PodTemplateList ListNamespacedPodTemplate (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodTemplateList> localVarResponse = ListNamespacedPodTemplateWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplateList</returns>
        public ApiResponse< V1PodTemplateList > ListNamespacedPodTemplateWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplateList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplateList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplateList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodTemplateList</returns>
        public async System.Threading.Tasks.Task<V1PodTemplateList> ListNamespacedPodTemplateAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodTemplateList> localVarResponse = await ListNamespacedPodTemplateAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplateList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodTemplateList>> ListNamespacedPodTemplateAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplateList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplateList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplateList)));
        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ReplicationControllerList</returns>
        public V1ReplicationControllerList ListNamespacedReplicationController (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ReplicationControllerList> localVarResponse = ListNamespacedReplicationControllerWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationControllerList</returns>
        public ApiResponse< V1ReplicationControllerList > ListNamespacedReplicationControllerWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationControllerList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationControllerList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationControllerList)));
        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ReplicationControllerList</returns>
        public async System.Threading.Tasks.Task<V1ReplicationControllerList> ListNamespacedReplicationControllerAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ReplicationControllerList> localVarResponse = await ListNamespacedReplicationControllerAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationControllerList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationControllerList>> ListNamespacedReplicationControllerAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationControllerList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationControllerList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationControllerList)));
        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ResourceQuotaList</returns>
        public V1ResourceQuotaList ListNamespacedResourceQuota (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ResourceQuotaList> localVarResponse = ListNamespacedResourceQuotaWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuotaList</returns>
        public ApiResponse< V1ResourceQuotaList > ListNamespacedResourceQuotaWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuotaList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuotaList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuotaList)));
        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ResourceQuotaList</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuotaList> ListNamespacedResourceQuotaAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ResourceQuotaList> localVarResponse = await ListNamespacedResourceQuotaAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuotaList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuotaList>> ListNamespacedResourceQuotaAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuotaList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuotaList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuotaList)));
        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1SecretList</returns>
        public V1SecretList ListNamespacedSecret (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1SecretList> localVarResponse = ListNamespacedSecretWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1SecretList</returns>
        public ApiResponse< V1SecretList > ListNamespacedSecretWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1SecretList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1SecretList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1SecretList)));
        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1SecretList</returns>
        public async System.Threading.Tasks.Task<V1SecretList> ListNamespacedSecretAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1SecretList> localVarResponse = await ListNamespacedSecretAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1SecretList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1SecretList>> ListNamespacedSecretAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1SecretList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1SecretList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1SecretList)));
        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceList</returns>
        public V1ServiceList ListNamespacedService (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceList> localVarResponse = ListNamespacedServiceWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceList</returns>
        public ApiResponse< V1ServiceList > ListNamespacedServiceWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceList)));
        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceList</returns>
        public async System.Threading.Tasks.Task<V1ServiceList> ListNamespacedServiceAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceList> localVarResponse = await ListNamespacedServiceAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceList>> ListNamespacedServiceAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceList)));
        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceAccountList</returns>
        public V1ServiceAccountList ListNamespacedServiceAccount (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceAccountList> localVarResponse = ListNamespacedServiceAccountWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccountList</returns>
        public ApiResponse< V1ServiceAccountList > ListNamespacedServiceAccountWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccountList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccountList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccountList)));
        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceAccountList</returns>
        public async System.Threading.Tasks.Task<V1ServiceAccountList> ListNamespacedServiceAccountAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceAccountList> localVarResponse = await ListNamespacedServiceAccountAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccountList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceAccountList>> ListNamespacedServiceAccountAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ListNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccountList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccountList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccountList)));
        }

        /// <summary>
        ///  list or watch objects of kind Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1NodeList</returns>
        public V1NodeList ListNode (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1NodeList> localVarResponse = ListNodeWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1NodeList</returns>
        public ApiResponse< V1NodeList > ListNodeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1NodeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1NodeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1NodeList)));
        }

        /// <summary>
        ///  list or watch objects of kind Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1NodeList</returns>
        public async System.Threading.Tasks.Task<V1NodeList> ListNodeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1NodeList> localVarResponse = await ListNodeAsyncWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1NodeList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1NodeList>> ListNodeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1NodeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1NodeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1NodeList)));
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PersistentVolumeList</returns>
        public V1PersistentVolumeList ListPersistentVolume (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PersistentVolumeList> localVarResponse = ListPersistentVolumeWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeList</returns>
        public ApiResponse< V1PersistentVolumeList > ListPersistentVolumeWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/persistentvolumes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeList)));
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PersistentVolumeList</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeList> ListPersistentVolumeAsync (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PersistentVolumeList> localVarResponse = await ListPersistentVolumeAsyncWithHttpInfo(pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeList>> ListPersistentVolumeAsyncWithHttpInfo (string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/persistentvolumes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeList)));
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PersistentVolumeClaimList</returns>
        public V1PersistentVolumeClaimList ListPersistentVolumeClaimForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PersistentVolumeClaimList> localVarResponse = ListPersistentVolumeClaimForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaimList</returns>
        public ApiResponse< V1PersistentVolumeClaimList > ListPersistentVolumeClaimForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersistentVolumeClaimForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaimList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaimList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaimList)));
        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaimList</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaimList> ListPersistentVolumeClaimForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PersistentVolumeClaimList> localVarResponse = await ListPersistentVolumeClaimForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaimList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaimList>> ListPersistentVolumeClaimForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/persistentvolumeclaims";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersistentVolumeClaimForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaimList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaimList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaimList)));
        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodList</returns>
        public V1PodList ListPodForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodList> localVarResponse = ListPodForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodList</returns>
        public ApiResponse< V1PodList > ListPodForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPodForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodList)));
        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodList</returns>
        public async System.Threading.Tasks.Task<V1PodList> ListPodForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodList> localVarResponse = await ListPodForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodList>> ListPodForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/pods";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPodForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1PodTemplateList</returns>
        public V1PodTemplateList ListPodTemplateForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodTemplateList> localVarResponse = ListPodTemplateForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplateList</returns>
        public ApiResponse< V1PodTemplateList > ListPodTemplateForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPodTemplateForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplateList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplateList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplateList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1PodTemplateList</returns>
        public async System.Threading.Tasks.Task<V1PodTemplateList> ListPodTemplateForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1PodTemplateList> localVarResponse = await ListPodTemplateForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplateList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodTemplateList>> ListPodTemplateForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/podtemplates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPodTemplateForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplateList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplateList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplateList)));
        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ReplicationControllerList</returns>
        public V1ReplicationControllerList ListReplicationControllerForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ReplicationControllerList> localVarResponse = ListReplicationControllerForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationControllerList</returns>
        public ApiResponse< V1ReplicationControllerList > ListReplicationControllerForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListReplicationControllerForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationControllerList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationControllerList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationControllerList)));
        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ReplicationControllerList</returns>
        public async System.Threading.Tasks.Task<V1ReplicationControllerList> ListReplicationControllerForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ReplicationControllerList> localVarResponse = await ListReplicationControllerForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationControllerList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationControllerList>> ListReplicationControllerForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/replicationcontrollers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListReplicationControllerForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationControllerList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationControllerList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationControllerList)));
        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ResourceQuotaList</returns>
        public V1ResourceQuotaList ListResourceQuotaForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ResourceQuotaList> localVarResponse = ListResourceQuotaForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuotaList</returns>
        public ApiResponse< V1ResourceQuotaList > ListResourceQuotaForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListResourceQuotaForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuotaList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuotaList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuotaList)));
        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ResourceQuotaList</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuotaList> ListResourceQuotaForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ResourceQuotaList> localVarResponse = await ListResourceQuotaForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuotaList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuotaList>> ListResourceQuotaForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/resourcequotas";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListResourceQuotaForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuotaList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuotaList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuotaList)));
        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1SecretList</returns>
        public V1SecretList ListSecretForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1SecretList> localVarResponse = ListSecretForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1SecretList</returns>
        public ApiResponse< V1SecretList > ListSecretForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListSecretForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1SecretList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1SecretList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1SecretList)));
        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1SecretList</returns>
        public async System.Threading.Tasks.Task<V1SecretList> ListSecretForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1SecretList> localVarResponse = await ListSecretForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1SecretList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1SecretList>> ListSecretForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/secrets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListSecretForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1SecretList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1SecretList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1SecretList)));
        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceAccountList</returns>
        public V1ServiceAccountList ListServiceAccountForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceAccountList> localVarResponse = ListServiceAccountForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccountList</returns>
        public ApiResponse< V1ServiceAccountList > ListServiceAccountForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListServiceAccountForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccountList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccountList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccountList)));
        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceAccountList</returns>
        public async System.Threading.Tasks.Task<V1ServiceAccountList> ListServiceAccountForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceAccountList> localVarResponse = await ListServiceAccountForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccountList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceAccountList>> ListServiceAccountForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/serviceaccounts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListServiceAccountForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccountList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccountList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccountList)));
        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1ServiceList</returns>
        public V1ServiceList ListServiceForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceList> localVarResponse = ListServiceForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1ServiceList</returns>
        public ApiResponse< V1ServiceList > ListServiceForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/services";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListServiceForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceList)));
        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1ServiceList</returns>
        public async System.Threading.Tasks.Task<V1ServiceList> ListServiceForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1ServiceList> localVarResponse = await ListServiceForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceList>> ListServiceForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/api/v1/services";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListServiceForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceList)));
        }

        /// <summary>
        ///  partially update the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace PatchNamespace (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = PatchNamespaceWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > PatchNamespaceWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespace");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  partially update the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> PatchNamespaceAsync (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await PatchNamespaceAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> PatchNamespaceAsyncWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespace");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  partially update status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace PatchNamespaceStatus (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = PatchNamespaceStatusWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > PatchNamespaceStatusWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespaceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespaceStatus");

            var localVarPath = "/api/v1/namespaces/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespaceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  partially update status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> PatchNamespaceStatusAsync (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await PatchNamespaceStatusAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> PatchNamespaceStatusAsyncWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespaceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespaceStatus");

            var localVarPath = "/api/v1/namespaces/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespaceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  partially update the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        public V1ConfigMap PatchNamespacedConfigMap (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = PatchNamespacedConfigMapWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        public ApiResponse< V1ConfigMap > PatchNamespacedConfigMapWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  partially update the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        public async System.Threading.Tasks.Task<V1ConfigMap> PatchNamespacedConfigMapAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = await PatchNamespacedConfigMapAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> PatchNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  partially update the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Endpoints</returns>
        public V1Endpoints PatchNamespacedEndpoints (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = PatchNamespacedEndpointsWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        public ApiResponse< V1Endpoints > PatchNamespacedEndpointsWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  partially update the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        public async System.Threading.Tasks.Task<V1Endpoints> PatchNamespacedEndpointsAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = await PatchNamespacedEndpointsAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> PatchNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  partially update the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Event</returns>
        public V1Event PatchNamespacedEvent (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Event> localVarResponse = PatchNamespacedEventWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        public ApiResponse< V1Event > PatchNamespacedEventWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  partially update the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Event</returns>
        public async System.Threading.Tasks.Task<V1Event> PatchNamespacedEventAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Event> localVarResponse = await PatchNamespacedEventAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Event>> PatchNamespacedEventAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  partially update the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1LimitRange</returns>
        public V1LimitRange PatchNamespacedLimitRange (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = PatchNamespacedLimitRangeWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        public ApiResponse< V1LimitRange > PatchNamespacedLimitRangeWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  partially update the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        public async System.Threading.Tasks.Task<V1LimitRange> PatchNamespacedLimitRangeAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = await PatchNamespacedLimitRangeAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> PatchNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  partially update the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim PatchNamespacedPersistentVolumeClaim (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = PatchNamespacedPersistentVolumeClaimWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > PatchNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  partially update the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await PatchNamespacedPersistentVolumeClaimAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  partially update status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim PatchNamespacedPersistentVolumeClaimStatus (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = PatchNamespacedPersistentVolumeClaimStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > PatchNamespacedPersistentVolumeClaimStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaimStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPersistentVolumeClaimStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  partially update status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> PatchNamespacedPersistentVolumeClaimStatusAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await PatchNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> PatchNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPersistentVolumeClaimStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPersistentVolumeClaimStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  partially update the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod PatchNamespacedPod (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = PatchNamespacedPodWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > PatchNamespacedPodWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  partially update the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> PatchNamespacedPodAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = await PatchNamespacedPodAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> PatchNamespacedPodAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  partially update status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod PatchNamespacedPodStatus (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = PatchNamespacedPodStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > PatchNamespacedPodStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPodStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPodStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPodStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  partially update status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> PatchNamespacedPodStatusAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = await PatchNamespacedPodStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> PatchNamespacedPodStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPodStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPodStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPodStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  partially update the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        public V1PodTemplate PatchNamespacedPodTemplate (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = PatchNamespacedPodTemplateWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        public ApiResponse< V1PodTemplate > PatchNamespacedPodTemplateWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  partially update the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        public async System.Threading.Tasks.Task<V1PodTemplate> PatchNamespacedPodTemplateAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = await PatchNamespacedPodTemplateAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> PatchNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  partially update the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController PatchNamespacedReplicationController (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = PatchNamespacedReplicationControllerWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > PatchNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  partially update the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> PatchNamespacedReplicationControllerAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await PatchNamespacedReplicationControllerAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> PatchNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  partially update scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Scale</returns>
        public V1Scale PatchNamespacedReplicationControllerScale (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Scale> localVarResponse = PatchNamespacedReplicationControllerScaleWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Scale</returns>
        public ApiResponse< V1Scale > PatchNamespacedReplicationControllerScaleWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedReplicationControllerScale");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedReplicationControllerScale");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedReplicationControllerScale");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedReplicationControllerScale", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Scale>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Scale) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Scale)));
        }

        /// <summary>
        ///  partially update scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Scale</returns>
        public async System.Threading.Tasks.Task<V1Scale> PatchNamespacedReplicationControllerScaleAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Scale> localVarResponse = await PatchNamespacedReplicationControllerScaleAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Scale)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Scale>> PatchNamespacedReplicationControllerScaleAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedReplicationControllerScale");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedReplicationControllerScale");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedReplicationControllerScale");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedReplicationControllerScale", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Scale>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Scale) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Scale)));
        }

        /// <summary>
        ///  partially update status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController PatchNamespacedReplicationControllerStatus (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = PatchNamespacedReplicationControllerStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > PatchNamespacedReplicationControllerStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedReplicationControllerStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedReplicationControllerStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedReplicationControllerStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedReplicationControllerStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  partially update status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> PatchNamespacedReplicationControllerStatusAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await PatchNamespacedReplicationControllerStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> PatchNamespacedReplicationControllerStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedReplicationControllerStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedReplicationControllerStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedReplicationControllerStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedReplicationControllerStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  partially update the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota PatchNamespacedResourceQuota (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = PatchNamespacedResourceQuotaWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > PatchNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  partially update the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> PatchNamespacedResourceQuotaAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await PatchNamespacedResourceQuotaAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  partially update status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota PatchNamespacedResourceQuotaStatus (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = PatchNamespacedResourceQuotaStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > PatchNamespacedResourceQuotaStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedResourceQuotaStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedResourceQuotaStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedResourceQuotaStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedResourceQuotaStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  partially update status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> PatchNamespacedResourceQuotaStatusAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await PatchNamespacedResourceQuotaStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> PatchNamespacedResourceQuotaStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedResourceQuotaStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedResourceQuotaStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedResourceQuotaStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedResourceQuotaStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  partially update the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Secret</returns>
        public V1Secret PatchNamespacedSecret (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Secret> localVarResponse = PatchNamespacedSecretWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        public ApiResponse< V1Secret > PatchNamespacedSecretWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  partially update the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        public async System.Threading.Tasks.Task<V1Secret> PatchNamespacedSecretAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Secret> localVarResponse = await PatchNamespacedSecretAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Secret>> PatchNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  partially update the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service PatchNamespacedService (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = PatchNamespacedServiceWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > PatchNamespacedServiceWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedService");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  partially update the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> PatchNamespacedServiceAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = await PatchNamespacedServiceAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> PatchNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedService");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  partially update the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        public V1ServiceAccount PatchNamespacedServiceAccount (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = PatchNamespacedServiceAccountWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        public ApiResponse< V1ServiceAccount > PatchNamespacedServiceAccountWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  partially update the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        public async System.Threading.Tasks.Task<V1ServiceAccount> PatchNamespacedServiceAccountAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = await PatchNamespacedServiceAccountAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> PatchNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  partially update status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service PatchNamespacedServiceStatus (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = PatchNamespacedServiceStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > PatchNamespacedServiceStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedServiceStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedServiceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedServiceStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedServiceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  partially update status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> PatchNamespacedServiceStatusAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = await PatchNamespacedServiceStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> PatchNamespacedServiceStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNamespacedServiceStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->PatchNamespacedServiceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNamespacedServiceStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedServiceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  partially update the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node PatchNode (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = PatchNodeWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > PatchNodeWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  partially update the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> PatchNodeAsync (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = await PatchNodeAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> PatchNodeAsyncWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  partially update status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node PatchNodeStatus (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = PatchNodeStatusWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > PatchNodeStatusWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNodeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNodeStatus");

            var localVarPath = "/api/v1/nodes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNodeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  partially update status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> PatchNodeStatusAsync (string name, Object body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = await PatchNodeStatusAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> PatchNodeStatusAsyncWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchNodeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchNodeStatus");

            var localVarPath = "/api/v1/nodes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNodeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  partially update the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume PatchPersistentVolume (string name, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = PatchPersistentVolumeWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > PatchPersistentVolumeWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchPersistentVolume");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchPersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  partially update the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> PatchPersistentVolumeAsync (string name, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await PatchPersistentVolumeAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> PatchPersistentVolumeAsyncWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchPersistentVolume");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchPersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  partially update status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume PatchPersistentVolumeStatus (string name, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = PatchPersistentVolumeStatusWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > PatchPersistentVolumeStatusWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchPersistentVolumeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchPersistentVolumeStatus");

            var localVarPath = "/api/v1/persistentvolumes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchPersistentVolumeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  partially update status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> PatchPersistentVolumeStatusAsync (string name, Object body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await PatchPersistentVolumeStatusAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> PatchPersistentVolumeStatusAsyncWithHttpInfo (string name, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->PatchPersistentVolumeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->PatchPersistentVolumeStatus");

            var localVarPath = "/api/v1/persistentvolumes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchPersistentVolumeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyDELETENamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyDELETENamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyDELETENamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyDELETENamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyDELETENamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyDELETENamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyDELETENamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyDELETENamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyDELETENamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyDELETENamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyDELETENamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy DELETE requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyDELETENamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyDELETENamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyDELETENamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyDELETENamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyDELETENamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyDELETENamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyDELETENamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyDELETENamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyDELETENamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyDELETENamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyDELETENamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyDELETENamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy DELETE requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyDELETENamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyDELETENamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyDELETENode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyDELETENodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyDELETENodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyDELETENodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyDELETENodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyDELETENodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyDELETENodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyDELETENodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyDELETENodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyDELETENodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyDELETENodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy DELETE requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyDELETENodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyDELETENodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyDELETENodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyDELETENodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyGETNamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyGETNamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyGETNamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyGETNamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyGETNamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyGETNamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyGETNamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyGETNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyGETNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyGETNamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyGETNamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy GET requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyGETNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyGETNamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyGETNamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyGETNamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyGETNamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyGETNamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyGETNamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyGETNamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyGETNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyGETNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyGETNamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyGETNamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy GET requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyGETNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyGETNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyGETNode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyGETNodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyGETNodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyGETNodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyGETNodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyGETNodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyGETNodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyGETNodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyGETNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyGETNodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyGETNodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy GET requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyGETNodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyGETNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyGETNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyGETNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyHEADNamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyHEADNamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyHEADNamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyHEADNamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyHEADNamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyHEADNamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyHEADNamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyHEADNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyHEADNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyHEADNamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyHEADNamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy HEAD requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyHEADNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyHEADNamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyHEADNamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyHEADNamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyHEADNamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyHEADNamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyHEADNamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyHEADNamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyHEADNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyHEADNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyHEADNamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyHEADNamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy HEAD requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyHEADNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyHEADNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyHEADNode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyHEADNodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyHEADNodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyHEADNodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyHEADNodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyHEADNodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyHEADNodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyHEADNodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyHEADNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyHEADNodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyHEADNodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy HEAD requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyHEADNodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyHEADNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyHEADNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyHEADNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyOPTIONSNamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyOPTIONSNamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyOPTIONSNamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyOPTIONSNamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyOPTIONSNamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyOPTIONSNamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyOPTIONSNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyOPTIONSNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyOPTIONSNamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy OPTIONS requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyOPTIONSNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyOPTIONSNamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyOPTIONSNamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyOPTIONSNamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyOPTIONSNamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyOPTIONSNamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyOPTIONSNamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyOPTIONSNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyOPTIONSNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyOPTIONSNamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyOPTIONSNamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy OPTIONS requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyOPTIONSNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyOPTIONSNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyOPTIONSNode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyOPTIONSNodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyOPTIONSNodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyOPTIONSNodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyOPTIONSNodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyOPTIONSNodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyOPTIONSNodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyOPTIONSNodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyOPTIONSNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyOPTIONSNodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyOPTIONSNodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy OPTIONS requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyOPTIONSNodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyOPTIONSNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyOPTIONSNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.OPTIONS, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyOPTIONSNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyPATCHNamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyPATCHNamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPATCHNamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPATCHNamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyPATCHNamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPATCHNamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPATCHNamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPATCHNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPATCHNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPATCHNamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPATCHNamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PATCH requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPATCHNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyPATCHNamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyPATCHNamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPATCHNamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPATCHNamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyPATCHNamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPATCHNamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPATCHNamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPATCHNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPATCHNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPATCHNamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPATCHNamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PATCH requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPATCHNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPATCHNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyPATCHNode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyPATCHNodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPATCHNodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPATCHNodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyPATCHNodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPATCHNodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPATCHNodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPATCHNodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPATCHNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPATCHNodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPATCHNodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PATCH requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPATCHNodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPATCHNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPATCHNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPATCHNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyPOSTNamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyPOSTNamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPOSTNamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPOSTNamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyPOSTNamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPOSTNamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPOSTNamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPOSTNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPOSTNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPOSTNamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPOSTNamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy POST requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPOSTNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyPOSTNamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyPOSTNamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPOSTNamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPOSTNamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyPOSTNamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPOSTNamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPOSTNamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPOSTNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPOSTNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPOSTNamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPOSTNamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy POST requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPOSTNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPOSTNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyPOSTNode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyPOSTNodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPOSTNodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPOSTNodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyPOSTNodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPOSTNodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPOSTNodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPOSTNodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPOSTNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPOSTNodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPOSTNodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy POST requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPOSTNodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPOSTNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPOSTNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPOSTNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyPUTNamespacedPod (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyPUTNamespacedPodWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPUTNamespacedPodWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPUTNamespacedPodAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyPUTNamespacedPodAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedPodAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedPod");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPUTNamespacedPodWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPUTNamespacedPodWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPUTNamespacedPodWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPUTNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPUTNamespacedPodWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPUTNamespacedPodWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PUT requests to Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedPodWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedPodWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedPodWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPUTNamespacedPodWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedPodWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>string</returns>
        public string ProxyPUTNamespacedService (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = ProxyPUTNamespacedServiceWithHttpInfo(name, _namespace);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPUTNamespacedServiceWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPUTNamespacedServiceAsync (string name, string _namespace)
        {
             ApiResponse<string> localVarResponse = await ProxyPUTNamespacedServiceAsyncWithHttpInfo(name, _namespace);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedServiceAsyncWithHttpInfo (string name, string _namespace)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedService");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPUTNamespacedServiceWithPath (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPUTNamespacedServiceWithPathWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPUTNamespacedServiceWithPathWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPUTNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPUTNamespacedServiceWithPathAsync (string name, string _namespace, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPUTNamespacedServiceWithPathAsyncWithHttpInfo(name, _namespace, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PUT requests to Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNamespacedServiceWithPathAsyncWithHttpInfo (string name, string _namespace, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNamespacedServiceWithPath");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ProxyPUTNamespacedServiceWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPUTNamespacedServiceWithPath");

            var localVarPath = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNamespacedServiceWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>string</returns>
        public string ProxyPUTNode (string name)
        {
             ApiResponse<string> localVarResponse = ProxyPUTNodeWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPUTNodeWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPUTNodeAsync (string name)
        {
             ApiResponse<string> localVarResponse = await ProxyPUTNodeAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNodeAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNode");

            var localVarPath = "/api/v1/proxy/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>string</returns>
        public string ProxyPUTNodeWithPath (string name, string path)
        {
             ApiResponse<string> localVarResponse = ProxyPUTNodeWithPathWithHttpInfo(name, path);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ProxyPUTNodeWithPathWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPUTNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ProxyPUTNodeWithPathAsync (string name, string path)
        {
             ApiResponse<string> localVarResponse = await ProxyPUTNodeWithPathAsyncWithHttpInfo(name, path);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  proxy PUT requests to Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="path">path to the resource</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ProxyPUTNodeWithPathAsyncWithHttpInfo (string name, string path)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ProxyPUTNodeWithPath");
            // verify the required parameter 'path' is set
            if (path == null)
                throw new ApiException(400, "Missing required parameter 'path' when calling Core_v1Api->ProxyPUTNodeWithPath");

            var localVarPath = "/api/v1/proxy/nodes/{name}/{path}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "*/*"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (path != null) localVarPathParams.Add("path", Configuration.ApiClient.ParameterToString(path)); // path parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProxyPUTNodeWithPath", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  read the specified ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ComponentStatus</returns>
        public V1ComponentStatus ReadComponentStatus (string name, string pretty = null)
        {
             ApiResponse<V1ComponentStatus> localVarResponse = ReadComponentStatusWithHttpInfo(name, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ComponentStatus</returns>
        public ApiResponse< V1ComponentStatus > ReadComponentStatusWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadComponentStatus");

            var localVarPath = "/api/v1/componentstatuses/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadComponentStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ComponentStatus>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ComponentStatus) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ComponentStatus)));
        }

        /// <summary>
        ///  read the specified ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ComponentStatus</returns>
        public async System.Threading.Tasks.Task<V1ComponentStatus> ReadComponentStatusAsync (string name, string pretty = null)
        {
             ApiResponse<V1ComponentStatus> localVarResponse = await ReadComponentStatusAsyncWithHttpInfo(name, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified ComponentStatus
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ComponentStatus</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ComponentStatus)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ComponentStatus>> ReadComponentStatusAsyncWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadComponentStatus");

            var localVarPath = "/api/v1/componentstatuses/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadComponentStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ComponentStatus>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ComponentStatus) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ComponentStatus)));
        }

        /// <summary>
        ///  read the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace ReadNamespace (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Namespace> localVarResponse = ReadNamespaceWithHttpInfo(name, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > ReadNamespaceWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  read the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> ReadNamespaceAsync (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await ReadNamespaceAsyncWithHttpInfo(name, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReadNamespaceAsyncWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  read status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace ReadNamespaceStatus (string name, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = ReadNamespaceStatusWithHttpInfo(name, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > ReadNamespaceStatusWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespaceStatus");

            var localVarPath = "/api/v1/namespaces/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespaceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  read status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> ReadNamespaceStatusAsync (string name, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await ReadNamespaceStatusAsyncWithHttpInfo(name, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReadNamespaceStatusAsyncWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespaceStatus");

            var localVarPath = "/api/v1/namespaces/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespaceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  read the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        public V1ConfigMap ReadNamespacedConfigMap (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = ReadNamespacedConfigMapWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        public ApiResponse< V1ConfigMap > ReadNamespacedConfigMapWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  read the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        public async System.Threading.Tasks.Task<V1ConfigMap> ReadNamespacedConfigMapAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = await ReadNamespacedConfigMapAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> ReadNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  read the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Endpoints</returns>
        public V1Endpoints ReadNamespacedEndpoints (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = ReadNamespacedEndpointsWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        public ApiResponse< V1Endpoints > ReadNamespacedEndpointsWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  read the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        public async System.Threading.Tasks.Task<V1Endpoints> ReadNamespacedEndpointsAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = await ReadNamespacedEndpointsAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> ReadNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  read the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Event</returns>
        public V1Event ReadNamespacedEvent (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Event> localVarResponse = ReadNamespacedEventWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        public ApiResponse< V1Event > ReadNamespacedEventWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  read the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Event</returns>
        public async System.Threading.Tasks.Task<V1Event> ReadNamespacedEventAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Event> localVarResponse = await ReadNamespacedEventAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Event>> ReadNamespacedEventAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  read the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1LimitRange</returns>
        public V1LimitRange ReadNamespacedLimitRange (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = ReadNamespacedLimitRangeWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        public ApiResponse< V1LimitRange > ReadNamespacedLimitRangeWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  read the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        public async System.Threading.Tasks.Task<V1LimitRange> ReadNamespacedLimitRangeAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = await ReadNamespacedLimitRangeAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> ReadNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  read the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim ReadNamespacedPersistentVolumeClaim (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = ReadNamespacedPersistentVolumeClaimWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > ReadNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  read the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await ReadNamespacedPersistentVolumeClaimAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  read status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim ReadNamespacedPersistentVolumeClaimStatus (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = ReadNamespacedPersistentVolumeClaimStatusWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > ReadNamespacedPersistentVolumeClaimStatusWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaimStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPersistentVolumeClaimStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  read status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReadNamespacedPersistentVolumeClaimStatusAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await ReadNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReadNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPersistentVolumeClaimStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPersistentVolumeClaimStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  read the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod ReadNamespacedPod (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Pod> localVarResponse = ReadNamespacedPodWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > ReadNamespacedPodWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  read the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> ReadNamespacedPodAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Pod> localVarResponse = await ReadNamespacedPodAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReadNamespacedPodAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  read log of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>string</returns>
        public string ReadNamespacedPodLog (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null)
        {
             ApiResponse<string> localVarResponse = ReadNamespacedPodLogWithHttpInfo(name, _namespace, container, follow, limitBytes, pretty, previous, sinceSeconds, tailLines, timestamps);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read log of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > ReadNamespacedPodLogWithHttpInfo (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPodLog");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPodLog");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/log";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (follow != null) localVarQueryParams.Add("follow", Configuration.ApiClient.ParameterToString(follow)); // query parameter
            if (limitBytes != null) localVarQueryParams.Add("limitBytes", Configuration.ApiClient.ParameterToString(limitBytes)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (previous != null) localVarQueryParams.Add("previous", Configuration.ApiClient.ParameterToString(previous)); // query parameter
            if (sinceSeconds != null) localVarQueryParams.Add("sinceSeconds", Configuration.ApiClient.ParameterToString(sinceSeconds)); // query parameter
            if (tailLines != null) localVarQueryParams.Add("tailLines", Configuration.ApiClient.ParameterToString(tailLines)); // query parameter
            if (timestamps != null) localVarQueryParams.Add("timestamps", Configuration.ApiClient.ParameterToString(timestamps)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodLog", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  read log of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ReadNamespacedPodLogAsync (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null)
        {
             ApiResponse<string> localVarResponse = await ReadNamespacedPodLogAsyncWithHttpInfo(name, _namespace, container, follow, limitBytes, pretty, previous, sinceSeconds, tailLines, timestamps);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read log of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="container">The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)</param>
        /// <param name="follow">Follow the log stream of the pod. Defaults to false. (optional)</param>
        /// <param name="limitBytes">If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="previous">Return previous terminated container logs. Defaults to false. (optional)</param>
        /// <param name="sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)</param>
        /// <param name="tailLines">If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)</param>
        /// <param name="timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> ReadNamespacedPodLogAsyncWithHttpInfo (string name, string _namespace, string container = null, bool? follow = null, int? limitBytes = null, string pretty = null, bool? previous = null, int? sinceSeconds = null, int? tailLines = null, bool? timestamps = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPodLog");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPodLog");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/log";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (container != null) localVarQueryParams.Add("container", Configuration.ApiClient.ParameterToString(container)); // query parameter
            if (follow != null) localVarQueryParams.Add("follow", Configuration.ApiClient.ParameterToString(follow)); // query parameter
            if (limitBytes != null) localVarQueryParams.Add("limitBytes", Configuration.ApiClient.ParameterToString(limitBytes)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (previous != null) localVarQueryParams.Add("previous", Configuration.ApiClient.ParameterToString(previous)); // query parameter
            if (sinceSeconds != null) localVarQueryParams.Add("sinceSeconds", Configuration.ApiClient.ParameterToString(sinceSeconds)); // query parameter
            if (tailLines != null) localVarQueryParams.Add("tailLines", Configuration.ApiClient.ParameterToString(tailLines)); // query parameter
            if (timestamps != null) localVarQueryParams.Add("timestamps", Configuration.ApiClient.ParameterToString(timestamps)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodLog", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        ///  read status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod ReadNamespacedPodStatus (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = ReadNamespacedPodStatusWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > ReadNamespacedPodStatusWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPodStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPodStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  read status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> ReadNamespacedPodStatusAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = await ReadNamespacedPodStatusAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReadNamespacedPodStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPodStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPodStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  read the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        public V1PodTemplate ReadNamespacedPodTemplate (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = ReadNamespacedPodTemplateWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        public ApiResponse< V1PodTemplate > ReadNamespacedPodTemplateWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  read the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        public async System.Threading.Tasks.Task<V1PodTemplate> ReadNamespacedPodTemplateAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = await ReadNamespacedPodTemplateAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> ReadNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  read the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController ReadNamespacedReplicationController (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = ReadNamespacedReplicationControllerWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > ReadNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  read the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> ReadNamespacedReplicationControllerAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await ReadNamespacedReplicationControllerAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReadNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  read scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Scale</returns>
        public V1Scale ReadNamespacedReplicationControllerScale (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Scale> localVarResponse = ReadNamespacedReplicationControllerScaleWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Scale</returns>
        public ApiResponse< V1Scale > ReadNamespacedReplicationControllerScaleWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedReplicationControllerScale");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedReplicationControllerScale");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedReplicationControllerScale", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Scale>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Scale) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Scale)));
        }

        /// <summary>
        ///  read scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Scale</returns>
        public async System.Threading.Tasks.Task<V1Scale> ReadNamespacedReplicationControllerScaleAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Scale> localVarResponse = await ReadNamespacedReplicationControllerScaleAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Scale)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Scale>> ReadNamespacedReplicationControllerScaleAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedReplicationControllerScale");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedReplicationControllerScale");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedReplicationControllerScale", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Scale>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Scale) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Scale)));
        }

        /// <summary>
        ///  read status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController ReadNamespacedReplicationControllerStatus (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = ReadNamespacedReplicationControllerStatusWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > ReadNamespacedReplicationControllerStatusWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedReplicationControllerStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedReplicationControllerStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedReplicationControllerStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  read status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> ReadNamespacedReplicationControllerStatusAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await ReadNamespacedReplicationControllerStatusAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReadNamespacedReplicationControllerStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedReplicationControllerStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedReplicationControllerStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedReplicationControllerStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  read the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota ReadNamespacedResourceQuota (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = ReadNamespacedResourceQuotaWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > ReadNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  read the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> ReadNamespacedResourceQuotaAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await ReadNamespacedResourceQuotaAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  read status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota ReadNamespacedResourceQuotaStatus (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = ReadNamespacedResourceQuotaStatusWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > ReadNamespacedResourceQuotaStatusWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedResourceQuotaStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedResourceQuotaStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedResourceQuotaStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  read status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> ReadNamespacedResourceQuotaStatusAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await ReadNamespacedResourceQuotaStatusAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReadNamespacedResourceQuotaStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedResourceQuotaStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedResourceQuotaStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedResourceQuotaStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  read the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Secret</returns>
        public V1Secret ReadNamespacedSecret (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Secret> localVarResponse = ReadNamespacedSecretWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        public ApiResponse< V1Secret > ReadNamespacedSecretWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  read the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        public async System.Threading.Tasks.Task<V1Secret> ReadNamespacedSecretAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Secret> localVarResponse = await ReadNamespacedSecretAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Secret>> ReadNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  read the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service ReadNamespacedService (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Service> localVarResponse = ReadNamespacedServiceWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > ReadNamespacedServiceWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  read the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> ReadNamespacedServiceAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Service> localVarResponse = await ReadNamespacedServiceAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> ReadNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  read the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        public V1ServiceAccount ReadNamespacedServiceAccount (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = ReadNamespacedServiceAccountWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        public ApiResponse< V1ServiceAccount > ReadNamespacedServiceAccountWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  read the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        public async System.Threading.Tasks.Task<V1ServiceAccount> ReadNamespacedServiceAccountAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = await ReadNamespacedServiceAccountAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> ReadNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  read status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service ReadNamespacedServiceStatus (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = ReadNamespacedServiceStatusWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > ReadNamespacedServiceStatusWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedServiceStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedServiceStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedServiceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  read status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> ReadNamespacedServiceStatusAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = await ReadNamespacedServiceStatusAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> ReadNamespacedServiceStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNamespacedServiceStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReadNamespacedServiceStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedServiceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  read the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node ReadNode (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Node> localVarResponse = ReadNodeWithHttpInfo(name, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > ReadNodeWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  read the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> ReadNodeAsync (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1Node> localVarResponse = await ReadNodeAsyncWithHttpInfo(name, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> ReadNodeAsyncWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  read status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node ReadNodeStatus (string name, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = ReadNodeStatusWithHttpInfo(name, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > ReadNodeStatusWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNodeStatus");

            var localVarPath = "/api/v1/nodes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNodeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  read status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> ReadNodeStatusAsync (string name, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = await ReadNodeStatusAsyncWithHttpInfo(name, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> ReadNodeStatusAsyncWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadNodeStatus");

            var localVarPath = "/api/v1/nodes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNodeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  read the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume ReadPersistentVolume (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = ReadPersistentVolumeWithHttpInfo(name, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > ReadPersistentVolumeWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadPersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  read the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> ReadPersistentVolumeAsync (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await ReadPersistentVolumeAsyncWithHttpInfo(name, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReadPersistentVolumeAsyncWithHttpInfo (string name, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadPersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadPersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  read status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume ReadPersistentVolumeStatus (string name, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = ReadPersistentVolumeStatusWithHttpInfo(name, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > ReadPersistentVolumeStatusWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadPersistentVolumeStatus");

            var localVarPath = "/api/v1/persistentvolumes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadPersistentVolumeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  read status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> ReadPersistentVolumeStatusAsync (string name, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await ReadPersistentVolumeStatusAsyncWithHttpInfo(name, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReadPersistentVolumeStatusAsyncWithHttpInfo (string name, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReadPersistentVolumeStatus");

            var localVarPath = "/api/v1/persistentvolumes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadPersistentVolumeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  replace the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace ReplaceNamespace (string name, V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = ReplaceNamespaceWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > ReplaceNamespaceWithHttpInfo (string name, V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespace");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  replace the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> ReplaceNamespaceAsync (string name, V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await ReplaceNamespaceAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReplaceNamespaceAsyncWithHttpInfo (string name, V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespace");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespace");

            var localVarPath = "/api/v1/namespaces/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespace", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  replace finalize of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace ReplaceNamespaceFinalize (string name, V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = ReplaceNamespaceFinalizeWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace finalize of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > ReplaceNamespaceFinalizeWithHttpInfo (string name, V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespaceFinalize");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespaceFinalize");

            var localVarPath = "/api/v1/namespaces/{name}/finalize";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespaceFinalize", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  replace finalize of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> ReplaceNamespaceFinalizeAsync (string name, V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await ReplaceNamespaceFinalizeAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace finalize of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReplaceNamespaceFinalizeAsyncWithHttpInfo (string name, V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespaceFinalize");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespaceFinalize");

            var localVarPath = "/api/v1/namespaces/{name}/finalize";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespaceFinalize", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  replace status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Namespace</returns>
        public V1Namespace ReplaceNamespaceStatus (string name, V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = ReplaceNamespaceStatusWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Namespace</returns>
        public ApiResponse< V1Namespace > ReplaceNamespaceStatusWithHttpInfo (string name, V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespaceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespaceStatus");

            var localVarPath = "/api/v1/namespaces/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespaceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  replace status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Namespace</returns>
        public async System.Threading.Tasks.Task<V1Namespace> ReplaceNamespaceStatusAsync (string name, V1Namespace body, string pretty = null)
        {
             ApiResponse<V1Namespace> localVarResponse = await ReplaceNamespaceStatusAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified Namespace
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Namespace</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Namespace)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Namespace>> ReplaceNamespaceStatusAsyncWithHttpInfo (string name, V1Namespace body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespaceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespaceStatus");

            var localVarPath = "/api/v1/namespaces/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespaceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Namespace>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Namespace) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Namespace)));
        }

        /// <summary>
        ///  replace the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ConfigMap</returns>
        public V1ConfigMap ReplaceNamespacedConfigMap (string name, string _namespace, V1ConfigMap body, string pretty = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = ReplaceNamespacedConfigMapWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ConfigMap</returns>
        public ApiResponse< V1ConfigMap > ReplaceNamespacedConfigMapWithHttpInfo (string name, string _namespace, V1ConfigMap body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  replace the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ConfigMap</returns>
        public async System.Threading.Tasks.Task<V1ConfigMap> ReplaceNamespacedConfigMapAsync (string name, string _namespace, V1ConfigMap body, string pretty = null)
        {
             ApiResponse<V1ConfigMap> localVarResponse = await ReplaceNamespacedConfigMapAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified ConfigMap
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ConfigMap</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ConfigMap)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ConfigMap>> ReplaceNamespacedConfigMapAsyncWithHttpInfo (string name, string _namespace, V1ConfigMap body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedConfigMap");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedConfigMap");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedConfigMap");

            var localVarPath = "/api/v1/namespaces/{namespace}/configmaps/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedConfigMap", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ConfigMap>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ConfigMap) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ConfigMap)));
        }

        /// <summary>
        ///  replace the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Endpoints</returns>
        public V1Endpoints ReplaceNamespacedEndpoints (string name, string _namespace, V1Endpoints body, string pretty = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = ReplaceNamespacedEndpointsWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Endpoints</returns>
        public ApiResponse< V1Endpoints > ReplaceNamespacedEndpointsWithHttpInfo (string name, string _namespace, V1Endpoints body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  replace the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Endpoints</returns>
        public async System.Threading.Tasks.Task<V1Endpoints> ReplaceNamespacedEndpointsAsync (string name, string _namespace, V1Endpoints body, string pretty = null)
        {
             ApiResponse<V1Endpoints> localVarResponse = await ReplaceNamespacedEndpointsAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Endpoints
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Endpoints</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Endpoints)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Endpoints>> ReplaceNamespacedEndpointsAsyncWithHttpInfo (string name, string _namespace, V1Endpoints body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedEndpoints");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedEndpoints");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedEndpoints");

            var localVarPath = "/api/v1/namespaces/{namespace}/endpoints/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedEndpoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Endpoints>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Endpoints) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Endpoints)));
        }

        /// <summary>
        ///  replace the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Event</returns>
        public V1Event ReplaceNamespacedEvent (string name, string _namespace, V1Event body, string pretty = null)
        {
             ApiResponse<V1Event> localVarResponse = ReplaceNamespacedEventWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Event</returns>
        public ApiResponse< V1Event > ReplaceNamespacedEventWithHttpInfo (string name, string _namespace, V1Event body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  replace the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Event</returns>
        public async System.Threading.Tasks.Task<V1Event> ReplaceNamespacedEventAsync (string name, string _namespace, V1Event body, string pretty = null)
        {
             ApiResponse<V1Event> localVarResponse = await ReplaceNamespacedEventAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Event
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Event</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Event)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Event>> ReplaceNamespacedEventAsyncWithHttpInfo (string name, string _namespace, V1Event body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedEvent");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedEvent");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedEvent");

            var localVarPath = "/api/v1/namespaces/{namespace}/events/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Event>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Event) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Event)));
        }

        /// <summary>
        ///  replace the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1LimitRange</returns>
        public V1LimitRange ReplaceNamespacedLimitRange (string name, string _namespace, V1LimitRange body, string pretty = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = ReplaceNamespacedLimitRangeWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1LimitRange</returns>
        public ApiResponse< V1LimitRange > ReplaceNamespacedLimitRangeWithHttpInfo (string name, string _namespace, V1LimitRange body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  replace the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1LimitRange</returns>
        public async System.Threading.Tasks.Task<V1LimitRange> ReplaceNamespacedLimitRangeAsync (string name, string _namespace, V1LimitRange body, string pretty = null)
        {
             ApiResponse<V1LimitRange> localVarResponse = await ReplaceNamespacedLimitRangeAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified LimitRange
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the LimitRange</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1LimitRange)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1LimitRange>> ReplaceNamespacedLimitRangeAsyncWithHttpInfo (string name, string _namespace, V1LimitRange body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedLimitRange");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedLimitRange");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedLimitRange");

            var localVarPath = "/api/v1/namespaces/{namespace}/limitranges/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedLimitRange", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1LimitRange>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1LimitRange) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1LimitRange)));
        }

        /// <summary>
        ///  replace the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim ReplaceNamespacedPersistentVolumeClaim (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = ReplaceNamespacedPersistentVolumeClaimWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > ReplaceNamespacedPersistentVolumeClaimWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  replace the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimAsync (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await ReplaceNamespacedPersistentVolumeClaimAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimAsyncWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaim");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaim");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaim");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPersistentVolumeClaim", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  replace status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolumeClaim</returns>
        public V1PersistentVolumeClaim ReplaceNamespacedPersistentVolumeClaimStatus (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = ReplaceNamespacedPersistentVolumeClaimStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolumeClaim</returns>
        public ApiResponse< V1PersistentVolumeClaim > ReplaceNamespacedPersistentVolumeClaimStatusWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaimStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPersistentVolumeClaimStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  replace status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolumeClaim</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolumeClaim> ReplaceNamespacedPersistentVolumeClaimStatusAsync (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
             ApiResponse<V1PersistentVolumeClaim> localVarResponse = await ReplaceNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified PersistentVolumeClaim
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolumeClaim</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolumeClaim)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolumeClaim>> ReplaceNamespacedPersistentVolumeClaimStatusAsyncWithHttpInfo (string name, string _namespace, V1PersistentVolumeClaim body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaimStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPersistentVolumeClaimStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPersistentVolumeClaimStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolumeClaim>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolumeClaim) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolumeClaim)));
        }

        /// <summary>
        ///  replace the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod ReplaceNamespacedPod (string name, string _namespace, V1Pod body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = ReplaceNamespacedPodWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > ReplaceNamespacedPodWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  replace the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> ReplaceNamespacedPodAsync (string name, string _namespace, V1Pod body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = await ReplaceNamespacedPodAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReplaceNamespacedPodAsyncWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPod");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPod");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPod");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPod", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  replace status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Pod</returns>
        public V1Pod ReplaceNamespacedPodStatus (string name, string _namespace, V1Pod body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = ReplaceNamespacedPodStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Pod</returns>
        public ApiResponse< V1Pod > ReplaceNamespacedPodStatusWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPodStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPodStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPodStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  replace status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Pod</returns>
        public async System.Threading.Tasks.Task<V1Pod> ReplaceNamespacedPodStatusAsync (string name, string _namespace, V1Pod body, string pretty = null)
        {
             ApiResponse<V1Pod> localVarResponse = await ReplaceNamespacedPodStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified Pod
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Pod</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Pod)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Pod>> ReplaceNamespacedPodStatusAsyncWithHttpInfo (string name, string _namespace, V1Pod body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPodStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPodStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPodStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/pods/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Pod>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Pod) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Pod)));
        }

        /// <summary>
        ///  replace the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PodTemplate</returns>
        public V1PodTemplate ReplaceNamespacedPodTemplate (string name, string _namespace, V1PodTemplate body, string pretty = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = ReplaceNamespacedPodTemplateWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PodTemplate</returns>
        public ApiResponse< V1PodTemplate > ReplaceNamespacedPodTemplateWithHttpInfo (string name, string _namespace, V1PodTemplate body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  replace the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PodTemplate</returns>
        public async System.Threading.Tasks.Task<V1PodTemplate> ReplaceNamespacedPodTemplateAsync (string name, string _namespace, V1PodTemplate body, string pretty = null)
        {
             ApiResponse<V1PodTemplate> localVarResponse = await ReplaceNamespacedPodTemplateAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified PodTemplate
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodTemplate</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PodTemplate)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PodTemplate>> ReplaceNamespacedPodTemplateAsyncWithHttpInfo (string name, string _namespace, V1PodTemplate body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedPodTemplate");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedPodTemplate");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedPodTemplate");

            var localVarPath = "/api/v1/namespaces/{namespace}/podtemplates/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PodTemplate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PodTemplate) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PodTemplate)));
        }

        /// <summary>
        ///  replace the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController ReplaceNamespacedReplicationController (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = ReplaceNamespacedReplicationControllerWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > ReplaceNamespacedReplicationControllerWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  replace the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> ReplaceNamespacedReplicationControllerAsync (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await ReplaceNamespacedReplicationControllerAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerAsyncWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedReplicationController");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedReplicationController");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedReplicationController");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedReplicationController", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  replace scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Scale</returns>
        public V1Scale ReplaceNamespacedReplicationControllerScale (string name, string _namespace, V1Scale body, string pretty = null)
        {
             ApiResponse<V1Scale> localVarResponse = ReplaceNamespacedReplicationControllerScaleWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Scale</returns>
        public ApiResponse< V1Scale > ReplaceNamespacedReplicationControllerScaleWithHttpInfo (string name, string _namespace, V1Scale body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedReplicationControllerScale");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedReplicationControllerScale");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedReplicationControllerScale");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedReplicationControllerScale", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Scale>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Scale) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Scale)));
        }

        /// <summary>
        ///  replace scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Scale</returns>
        public async System.Threading.Tasks.Task<V1Scale> ReplaceNamespacedReplicationControllerScaleAsync (string name, string _namespace, V1Scale body, string pretty = null)
        {
             ApiResponse<V1Scale> localVarResponse = await ReplaceNamespacedReplicationControllerScaleAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace scale of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Scale</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Scale)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Scale>> ReplaceNamespacedReplicationControllerScaleAsyncWithHttpInfo (string name, string _namespace, V1Scale body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedReplicationControllerScale");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedReplicationControllerScale");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedReplicationControllerScale");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedReplicationControllerScale", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Scale>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Scale) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Scale)));
        }

        /// <summary>
        ///  replace status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ReplicationController</returns>
        public V1ReplicationController ReplaceNamespacedReplicationControllerStatus (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = ReplaceNamespacedReplicationControllerStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ReplicationController</returns>
        public ApiResponse< V1ReplicationController > ReplaceNamespacedReplicationControllerStatusWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedReplicationControllerStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedReplicationControllerStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedReplicationControllerStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedReplicationControllerStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  replace status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ReplicationController</returns>
        public async System.Threading.Tasks.Task<V1ReplicationController> ReplaceNamespacedReplicationControllerStatusAsync (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
             ApiResponse<V1ReplicationController> localVarResponse = await ReplaceNamespacedReplicationControllerStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified ReplicationController
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ReplicationController</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ReplicationController)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ReplicationController>> ReplaceNamespacedReplicationControllerStatusAsyncWithHttpInfo (string name, string _namespace, V1ReplicationController body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedReplicationControllerStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedReplicationControllerStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedReplicationControllerStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedReplicationControllerStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ReplicationController>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ReplicationController) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ReplicationController)));
        }

        /// <summary>
        ///  replace the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota ReplaceNamespacedResourceQuota (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = ReplaceNamespacedResourceQuotaWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > ReplaceNamespacedResourceQuotaWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  replace the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> ReplaceNamespacedResourceQuotaAsync (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await ReplaceNamespacedResourceQuotaAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaAsyncWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedResourceQuota");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedResourceQuota");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedResourceQuota");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedResourceQuota", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  replace status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ResourceQuota</returns>
        public V1ResourceQuota ReplaceNamespacedResourceQuotaStatus (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = ReplaceNamespacedResourceQuotaStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ResourceQuota</returns>
        public ApiResponse< V1ResourceQuota > ReplaceNamespacedResourceQuotaStatusWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedResourceQuotaStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedResourceQuotaStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedResourceQuotaStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedResourceQuotaStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  replace status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ResourceQuota</returns>
        public async System.Threading.Tasks.Task<V1ResourceQuota> ReplaceNamespacedResourceQuotaStatusAsync (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
             ApiResponse<V1ResourceQuota> localVarResponse = await ReplaceNamespacedResourceQuotaStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified ResourceQuota
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ResourceQuota</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ResourceQuota)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ResourceQuota>> ReplaceNamespacedResourceQuotaStatusAsyncWithHttpInfo (string name, string _namespace, V1ResourceQuota body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedResourceQuotaStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedResourceQuotaStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedResourceQuotaStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedResourceQuotaStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ResourceQuota>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ResourceQuota) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ResourceQuota)));
        }

        /// <summary>
        ///  replace the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Secret</returns>
        public V1Secret ReplaceNamespacedSecret (string name, string _namespace, V1Secret body, string pretty = null)
        {
             ApiResponse<V1Secret> localVarResponse = ReplaceNamespacedSecretWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Secret</returns>
        public ApiResponse< V1Secret > ReplaceNamespacedSecretWithHttpInfo (string name, string _namespace, V1Secret body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  replace the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Secret</returns>
        public async System.Threading.Tasks.Task<V1Secret> ReplaceNamespacedSecretAsync (string name, string _namespace, V1Secret body, string pretty = null)
        {
             ApiResponse<V1Secret> localVarResponse = await ReplaceNamespacedSecretAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Secret
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Secret</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Secret)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Secret>> ReplaceNamespacedSecretAsyncWithHttpInfo (string name, string _namespace, V1Secret body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedSecret");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedSecret");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedSecret");

            var localVarPath = "/api/v1/namespaces/{namespace}/secrets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedSecret", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Secret>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Secret) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Secret)));
        }

        /// <summary>
        ///  replace the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service ReplaceNamespacedService (string name, string _namespace, V1Service body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = ReplaceNamespacedServiceWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > ReplaceNamespacedServiceWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedService");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  replace the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> ReplaceNamespacedServiceAsync (string name, string _namespace, V1Service body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = await ReplaceNamespacedServiceAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> ReplaceNamespacedServiceAsyncWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedService");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedService");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedService");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  replace the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1ServiceAccount</returns>
        public V1ServiceAccount ReplaceNamespacedServiceAccount (string name, string _namespace, V1ServiceAccount body, string pretty = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = ReplaceNamespacedServiceAccountWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1ServiceAccount</returns>
        public ApiResponse< V1ServiceAccount > ReplaceNamespacedServiceAccountWithHttpInfo (string name, string _namespace, V1ServiceAccount body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  replace the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1ServiceAccount</returns>
        public async System.Threading.Tasks.Task<V1ServiceAccount> ReplaceNamespacedServiceAccountAsync (string name, string _namespace, V1ServiceAccount body, string pretty = null)
        {
             ApiResponse<V1ServiceAccount> localVarResponse = await ReplaceNamespacedServiceAccountAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified ServiceAccount
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the ServiceAccount</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1ServiceAccount)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1ServiceAccount>> ReplaceNamespacedServiceAccountAsyncWithHttpInfo (string name, string _namespace, V1ServiceAccount body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedServiceAccount");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedServiceAccount");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedServiceAccount");

            var localVarPath = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedServiceAccount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1ServiceAccount>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1ServiceAccount) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1ServiceAccount)));
        }

        /// <summary>
        ///  replace status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Service</returns>
        public V1Service ReplaceNamespacedServiceStatus (string name, string _namespace, V1Service body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = ReplaceNamespacedServiceStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Service</returns>
        public ApiResponse< V1Service > ReplaceNamespacedServiceStatusWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedServiceStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedServiceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedServiceStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedServiceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  replace status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Service</returns>
        public async System.Threading.Tasks.Task<V1Service> ReplaceNamespacedServiceStatusAsync (string name, string _namespace, V1Service body, string pretty = null)
        {
             ApiResponse<V1Service> localVarResponse = await ReplaceNamespacedServiceStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified Service
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Service</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Service)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Service>> ReplaceNamespacedServiceStatusAsyncWithHttpInfo (string name, string _namespace, V1Service body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNamespacedServiceStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Core_v1Api->ReplaceNamespacedServiceStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNamespacedServiceStatus");

            var localVarPath = "/api/v1/namespaces/{namespace}/services/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedServiceStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Service>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Service) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Service)));
        }

        /// <summary>
        ///  replace the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node ReplaceNode (string name, V1Node body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = ReplaceNodeWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > ReplaceNodeWithHttpInfo (string name, V1Node body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  replace the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> ReplaceNodeAsync (string name, V1Node body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = await ReplaceNodeAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> ReplaceNodeAsyncWithHttpInfo (string name, V1Node body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNode");

            var localVarPath = "/api/v1/nodes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  replace status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1Node</returns>
        public V1Node ReplaceNodeStatus (string name, V1Node body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = ReplaceNodeStatusWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1Node</returns>
        public ApiResponse< V1Node > ReplaceNodeStatusWithHttpInfo (string name, V1Node body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNodeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNodeStatus");

            var localVarPath = "/api/v1/nodes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNodeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  replace status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1Node</returns>
        public async System.Threading.Tasks.Task<V1Node> ReplaceNodeStatusAsync (string name, V1Node body, string pretty = null)
        {
             ApiResponse<V1Node> localVarResponse = await ReplaceNodeStatusAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified Node
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the Node</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Node>> ReplaceNodeStatusAsyncWithHttpInfo (string name, V1Node body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplaceNodeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplaceNodeStatus");

            var localVarPath = "/api/v1/nodes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNodeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Node) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Node)));
        }

        /// <summary>
        ///  replace the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume ReplacePersistentVolume (string name, V1PersistentVolume body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = ReplacePersistentVolumeWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > ReplacePersistentVolumeWithHttpInfo (string name, V1PersistentVolume body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplacePersistentVolume");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplacePersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplacePersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  replace the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> ReplacePersistentVolumeAsync (string name, V1PersistentVolume body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await ReplacePersistentVolumeAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReplacePersistentVolumeAsyncWithHttpInfo (string name, V1PersistentVolume body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplacePersistentVolume");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplacePersistentVolume");

            var localVarPath = "/api/v1/persistentvolumes/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplacePersistentVolume", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  replace status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1PersistentVolume</returns>
        public V1PersistentVolume ReplacePersistentVolumeStatus (string name, V1PersistentVolume body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = ReplacePersistentVolumeStatusWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1PersistentVolume</returns>
        public ApiResponse< V1PersistentVolume > ReplacePersistentVolumeStatusWithHttpInfo (string name, V1PersistentVolume body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplacePersistentVolumeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplacePersistentVolumeStatus");

            var localVarPath = "/api/v1/persistentvolumes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplacePersistentVolumeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

        /// <summary>
        ///  replace status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1PersistentVolume</returns>
        public async System.Threading.Tasks.Task<V1PersistentVolume> ReplacePersistentVolumeStatusAsync (string name, V1PersistentVolume body, string pretty = null)
        {
             ApiResponse<V1PersistentVolume> localVarResponse = await ReplacePersistentVolumeStatusAsyncWithHttpInfo(name, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified PersistentVolume
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PersistentVolume</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1PersistentVolume)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1PersistentVolume>> ReplacePersistentVolumeStatusAsyncWithHttpInfo (string name, V1PersistentVolume body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Core_v1Api->ReplacePersistentVolumeStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Core_v1Api->ReplacePersistentVolumeStatus");

            var localVarPath = "/api/v1/persistentvolumes/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplacePersistentVolumeStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1PersistentVolume>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1PersistentVolume) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1PersistentVolume)));
        }

    }
}
