/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.10
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Kubernetes.DotNet.Client;
using Kubernetes.DotNet.Model;

namespace Kubernetes.DotNet.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPolicy_v1beta1Api : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget CreateNamespacedPodDisruptionBudget (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> CreateNamespacedPodDisruptionBudgetWithHttpInfo (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteCollectionNamespacedPodDisruptionBudget (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        V1Status DeleteNamespacedPodDisruptionBudget (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        ApiResponse<V1Status> DeleteNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>V1APIResourceList</returns>
        V1APIResourceList GetAPIResources ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of V1APIResourceList</returns>
        ApiResponse<V1APIResourceList> GetAPIResourcesWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudgetList</returns>
        V1beta1PodDisruptionBudgetList ListNamespacedPodDisruptionBudget (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudgetList</returns>
        ApiResponse<V1beta1PodDisruptionBudgetList> ListNamespacedPodDisruptionBudgetWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudgetList</returns>
        V1beta1PodDisruptionBudgetList ListPodDisruptionBudgetForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudgetList</returns>
        ApiResponse<V1beta1PodDisruptionBudgetList> ListPodDisruptionBudgetForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget PatchNamespacedPodDisruptionBudget (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget PatchNamespacedPodDisruptionBudgetStatus (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget ReadNamespacedPodDisruptionBudget (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget ReadNamespacedPodDisruptionBudgetStatus (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetStatusWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget ReplaceNamespacedPodDisruptionBudget (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        V1beta1PodDisruptionBudget ReplaceNamespacedPodDisruptionBudgetStatus (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        ApiResponse<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetStatusWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> CreateNamespacedPodDisruptionBudgetAsync (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// create a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> CreateNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPodDisruptionBudgetAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete collection of PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        System.Threading.Tasks.Task<V1Status> DeleteNamespacedPodDisruptionBudgetAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// delete a PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of V1APIResourceList</returns>
        System.Threading.Tasks.Task<V1APIResourceList> GetAPIResourcesAsync ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// get available resources
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (V1APIResourceList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1APIResourceList>> GetAPIResourcesAsyncWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudgetList</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudgetList> ListNamespacedPodDisruptionBudgetAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudgetList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudgetList>> ListNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudgetList</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudgetList> ListPodDisruptionBudgetForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch objects of kind PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudgetList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudgetList>> ListPodDisruptionBudgetForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetStatusAsync (string name, string _namespace, Object body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetStatusAsync (string name, string _namespace, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetAsync (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetStatusAsync (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified PodDisruptionBudget
        /// </remarks>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Policy_v1beta1Api : IPolicy_v1beta1Api
    {
        private Kubernetes.DotNet.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="Policy_v1beta1Api"/> class.
        /// </summary>
        /// <returns></returns>
        public Policy_v1beta1Api(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Kubernetes.DotNet.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Policy_v1beta1Api"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public Policy_v1beta1Api(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Kubernetes.DotNet.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Kubernetes.DotNet.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        ///  create a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget CreateNamespacedPodDisruptionBudget (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = CreateNamespacedPodDisruptionBudgetWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  create a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > CreateNamespacedPodDisruptionBudgetWithHttpInfo (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->CreateNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->CreateNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  create a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> CreateNamespacedPodDisruptionBudgetAsync (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await CreateNamespacedPodDisruptionBudgetAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  create a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> CreateNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->CreateNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->CreateNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  delete collection of PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteCollectionNamespacedPodDisruptionBudget (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete collection of PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->DeleteCollectionNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete collection of PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteCollectionNamespacedPodDisruptionBudgetAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteCollectionNamespacedPodDisruptionBudgetAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete collection of PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteCollectionNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->DeleteCollectionNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollectionNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>V1Status</returns>
        public V1Status DeleteNamespacedPodDisruptionBudget (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = DeleteNamespacedPodDisruptionBudgetWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  delete a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>ApiResponse of V1Status</returns>
        public ApiResponse< V1Status > DeleteNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->DeleteNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->DeleteNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->DeleteNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  delete a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of V1Status</returns>
        public async System.Threading.Tasks.Task<V1Status> DeleteNamespacedPodDisruptionBudgetAsync (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
             ApiResponse<V1Status> localVarResponse = await DeleteNamespacedPodDisruptionBudgetAsyncWithHttpInfo(name, _namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  delete a PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <returns>Task of ApiResponse (V1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1Status>> DeleteNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, V1DeleteOptions body, string pretty = null, int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->DeleteNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->DeleteNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->DeleteNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (gracePeriodSeconds != null) localVarQueryParams.Add("gracePeriodSeconds", Configuration.ApiClient.ParameterToString(gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.Add("orphanDependents", Configuration.ApiClient.ParameterToString(orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.Add("propagationPolicy", Configuration.ApiClient.ParameterToString(propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1Status) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1Status)));
        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>V1APIResourceList</returns>
        public V1APIResourceList GetAPIResources ()
        {
             ApiResponse<V1APIResourceList> localVarResponse = GetAPIResourcesWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of V1APIResourceList</returns>
        public ApiResponse< V1APIResourceList > GetAPIResourcesWithHttpInfo ()
        {

            var localVarPath = "/apis/policy/v1beta1/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/yaml", 
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAPIResources", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1APIResourceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1APIResourceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1APIResourceList)));
        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of V1APIResourceList</returns>
        public async System.Threading.Tasks.Task<V1APIResourceList> GetAPIResourcesAsync ()
        {
             ApiResponse<V1APIResourceList> localVarResponse = await GetAPIResourcesAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        ///  get available resources
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (V1APIResourceList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1APIResourceList>> GetAPIResourcesAsyncWithHttpInfo ()
        {

            var localVarPath = "/apis/policy/v1beta1/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/yaml", 
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAPIResources", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1APIResourceList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1APIResourceList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1APIResourceList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudgetList</returns>
        public V1beta1PodDisruptionBudgetList ListNamespacedPodDisruptionBudget (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1beta1PodDisruptionBudgetList> localVarResponse = ListNamespacedPodDisruptionBudgetWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudgetList</returns>
        public ApiResponse< V1beta1PodDisruptionBudgetList > ListNamespacedPodDisruptionBudgetWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ListNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudgetList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudgetList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudgetList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudgetList</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudgetList> ListNamespacedPodDisruptionBudgetAsync (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1beta1PodDisruptionBudgetList> localVarResponse = await ListNamespacedPodDisruptionBudgetAsyncWithHttpInfo(_namespace, pretty, fieldSelector, includeUninitialized, labelSelector, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudgetList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudgetList>> ListNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string _namespace, string pretty = null, string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ListNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudgetList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudgetList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudgetList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudgetList</returns>
        public V1beta1PodDisruptionBudgetList ListPodDisruptionBudgetForAllNamespaces (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1beta1PodDisruptionBudgetList> localVarResponse = ListPodDisruptionBudgetForAllNamespacesWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudgetList</returns>
        public ApiResponse< V1beta1PodDisruptionBudgetList > ListPodDisruptionBudgetForAllNamespacesWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/apis/policy/v1beta1/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPodDisruptionBudgetForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudgetList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudgetList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudgetList)));
        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudgetList</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudgetList> ListPodDisruptionBudgetForAllNamespacesAsync (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {
             ApiResponse<V1beta1PodDisruptionBudgetList> localVarResponse = await ListPodDisruptionBudgetForAllNamespacesAsyncWithHttpInfo(fieldSelector, includeUninitialized, labelSelector, pretty, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch objects of kind PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="includeUninitialized">If true, partially initialized resources are included in the response. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudgetList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudgetList>> ListPodDisruptionBudgetForAllNamespacesAsyncWithHttpInfo (string fieldSelector = null, bool? includeUninitialized = null, string labelSelector = null, string pretty = null, string resourceVersion = null, int? timeoutSeconds = null, bool? watch = null)
        {

            var localVarPath = "/apis/policy/v1beta1/poddisruptionbudgets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf",
                "application/json;stream=watch",
                "application/vnd.kubernetes.protobuf;stream=watch"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fieldSelector != null) localVarQueryParams.Add("fieldSelector", Configuration.ApiClient.ParameterToString(fieldSelector)); // query parameter
            if (includeUninitialized != null) localVarQueryParams.Add("includeUninitialized", Configuration.ApiClient.ParameterToString(includeUninitialized)); // query parameter
            if (labelSelector != null) localVarQueryParams.Add("labelSelector", Configuration.ApiClient.ParameterToString(labelSelector)); // query parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (resourceVersion != null) localVarQueryParams.Add("resourceVersion", Configuration.ApiClient.ParameterToString(resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.Add("timeoutSeconds", Configuration.ApiClient.ParameterToString(timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.Add("watch", Configuration.ApiClient.ParameterToString(watch)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPodDisruptionBudgetForAllNamespaces", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudgetList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudgetList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudgetList)));
        }

        /// <summary>
        ///  partially update the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget PatchNamespacedPodDisruptionBudget (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = PatchNamespacedPodDisruptionBudgetWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > PatchNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  partially update the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await PatchNamespacedPodDisruptionBudgetAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  partially update status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget PatchNamespacedPodDisruptionBudgetStatus (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = PatchNamespacedPodDisruptionBudgetStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > PatchNamespacedPodDisruptionBudgetStatusWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudgetStatus");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodDisruptionBudgetStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  partially update status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> PatchNamespacedPodDisruptionBudgetStatusAsync (string name, string _namespace, Object body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await PatchNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> PatchNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo (string name, string _namespace, Object body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->PatchNamespacedPodDisruptionBudgetStatus");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json", 
                "application/strategic-merge-patch+json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchNamespacedPodDisruptionBudgetStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  read the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget ReadNamespacedPodDisruptionBudget (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = ReadNamespacedPodDisruptionBudgetWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > ReadNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  read the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetAsync (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await ReadNamespacedPodDisruptionBudgetAsyncWithHttpInfo(name, _namespace, pretty, exact, export);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="exact">Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)</param>
        /// <param name="export">Should this value be exported.  Export strips fields that a user can not specify. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, string pretty = null, bool? exact = null, bool? export = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (exact != null) localVarQueryParams.Add("exact", Configuration.ApiClient.ParameterToString(exact)); // query parameter
            if (export != null) localVarQueryParams.Add("export", Configuration.ApiClient.ParameterToString(export)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  read status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget ReadNamespacedPodDisruptionBudgetStatus (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = ReadNamespacedPodDisruptionBudgetStatusWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > ReadNamespacedPodDisruptionBudgetStatusWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudgetStatus");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodDisruptionBudgetStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  read status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReadNamespacedPodDisruptionBudgetStatusAsync (string name, string _namespace, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await ReadNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo(name, _namespace, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReadNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo (string name, string _namespace, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReadNamespacedPodDisruptionBudgetStatus");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReadNamespacedPodDisruptionBudgetStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  replace the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget ReplaceNamespacedPodDisruptionBudget (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = ReplaceNamespacedPodDisruptionBudgetWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > ReplaceNamespacedPodDisruptionBudgetWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  replace the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetAsync (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await ReplaceNamespacedPodDisruptionBudgetAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetAsyncWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudget");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudget");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudget");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodDisruptionBudget", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  replace status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>V1beta1PodDisruptionBudget</returns>
        public V1beta1PodDisruptionBudget ReplaceNamespacedPodDisruptionBudgetStatus (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = ReplaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of V1beta1PodDisruptionBudget</returns>
        public ApiResponse< V1beta1PodDisruptionBudget > ReplaceNamespacedPodDisruptionBudgetStatusWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudgetStatus");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodDisruptionBudgetStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

        /// <summary>
        ///  replace status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of V1beta1PodDisruptionBudget</returns>
        public async System.Threading.Tasks.Task<V1beta1PodDisruptionBudget> ReplaceNamespacedPodDisruptionBudgetStatusAsync (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
             ApiResponse<V1beta1PodDisruptionBudget> localVarResponse = await ReplaceNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo(name, _namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified PodDisruptionBudget
        /// </summary>
        /// <exception cref="Kubernetes.DotNet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">name of the PodDisruptionBudget</param>
        /// <param name="_namespace">object name and auth scope, such as for teams and projects</param>
        /// <param name="body"></param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (V1beta1PodDisruptionBudget)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V1beta1PodDisruptionBudget>> ReplaceNamespacedPodDisruptionBudgetStatusAsyncWithHttpInfo (string name, string _namespace, V1beta1PodDisruptionBudget body, string pretty = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudgetStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling Policy_v1beta1Api->ReplaceNamespacedPodDisruptionBudgetStatus");

            var localVarPath = "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (_namespace != null) localVarPathParams.Add("namespace", Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.Add("pretty", Configuration.ApiClient.ParameterToString(pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (BearerToken) required
            if (!String.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("authorization")))
            {
                localVarHeaderParams["authorization"] = Configuration.GetApiKeyWithPrefix("authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNamespacedPodDisruptionBudgetStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V1beta1PodDisruptionBudget>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (V1beta1PodDisruptionBudget) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V1beta1PodDisruptionBudget)));
        }

    }
}
