/* 
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.10
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = Kubernetes.DotNet.Client.SwaggerDateConverter;

namespace Kubernetes.DotNet.Model
{
    /// <summary>
    /// Pod Security Policy Spec defines the policy enforced.
    /// </summary>
    [DataContract]
    public partial class V1beta1PodSecurityPolicySpec :  IEquatable<V1beta1PodSecurityPolicySpec>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="V1beta1PodSecurityPolicySpec" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected V1beta1PodSecurityPolicySpec() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="V1beta1PodSecurityPolicySpec" /> class.
        /// </summary>
        /// <param name="AllowedCapabilities">AllowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field may be added at the pod author&#39;s discretion. You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities..</param>
        /// <param name="DefaultAddCapabilities">DefaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capabiility in both DefaultAddCapabilities and RequiredDropCapabilities..</param>
        /// <param name="FsGroup">FSGroup is the strategy that will dictate what fs group is used by the SecurityContext. (required).</param>
        /// <param name="HostIPC">hostIPC determines if the policy allows the use of HostIPC in the pod spec..</param>
        /// <param name="HostNetwork">hostNetwork determines if the policy allows the use of HostNetwork in the pod spec..</param>
        /// <param name="HostPID">hostPID determines if the policy allows the use of HostPID in the pod spec..</param>
        /// <param name="HostPorts">hostPorts determines which host port ranges are allowed to be exposed..</param>
        /// <param name="Privileged">privileged determines if a pod can request to be run as privileged..</param>
        /// <param name="ReadOnlyRootFilesystem">ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to..</param>
        /// <param name="RequiredDropCapabilities">RequiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added..</param>
        /// <param name="RunAsUser">runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set. (required).</param>
        /// <param name="SeLinux">seLinux is the strategy that will dictate the allowable labels that may be set. (required).</param>
        /// <param name="SupplementalGroups">SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext. (required).</param>
        /// <param name="Volumes">volumes is a white list of allowed volume plugins.  Empty indicates that all plugins may be used..</param>
        public V1beta1PodSecurityPolicySpec(List<string> AllowedCapabilities = default(List<string>), List<string> DefaultAddCapabilities = default(List<string>), V1beta1FSGroupStrategyOptions FsGroup = default(V1beta1FSGroupStrategyOptions), bool? HostIPC = default(bool?), bool? HostNetwork = default(bool?), bool? HostPID = default(bool?), List<V1beta1HostPortRange> HostPorts = default(List<V1beta1HostPortRange>), bool? Privileged = default(bool?), bool? ReadOnlyRootFilesystem = default(bool?), List<string> RequiredDropCapabilities = default(List<string>), V1beta1RunAsUserStrategyOptions RunAsUser = default(V1beta1RunAsUserStrategyOptions), V1beta1SELinuxStrategyOptions SeLinux = default(V1beta1SELinuxStrategyOptions), V1beta1SupplementalGroupsStrategyOptions SupplementalGroups = default(V1beta1SupplementalGroupsStrategyOptions), List<string> Volumes = default(List<string>))
        {
            // to ensure "FsGroup" is required (not null)
            if (FsGroup == null)
            {
                throw new InvalidDataException("FsGroup is a required property for V1beta1PodSecurityPolicySpec and cannot be null");
            }
            else
            {
                this.FsGroup = FsGroup;
            }
            // to ensure "RunAsUser" is required (not null)
            if (RunAsUser == null)
            {
                throw new InvalidDataException("RunAsUser is a required property for V1beta1PodSecurityPolicySpec and cannot be null");
            }
            else
            {
                this.RunAsUser = RunAsUser;
            }
            // to ensure "SeLinux" is required (not null)
            if (SeLinux == null)
            {
                throw new InvalidDataException("SeLinux is a required property for V1beta1PodSecurityPolicySpec and cannot be null");
            }
            else
            {
                this.SeLinux = SeLinux;
            }
            // to ensure "SupplementalGroups" is required (not null)
            if (SupplementalGroups == null)
            {
                throw new InvalidDataException("SupplementalGroups is a required property for V1beta1PodSecurityPolicySpec and cannot be null");
            }
            else
            {
                this.SupplementalGroups = SupplementalGroups;
            }
            this.AllowedCapabilities = AllowedCapabilities;
            this.DefaultAddCapabilities = DefaultAddCapabilities;
            this.HostIPC = HostIPC;
            this.HostNetwork = HostNetwork;
            this.HostPID = HostPID;
            this.HostPorts = HostPorts;
            this.Privileged = Privileged;
            this.ReadOnlyRootFilesystem = ReadOnlyRootFilesystem;
            this.RequiredDropCapabilities = RequiredDropCapabilities;
            this.Volumes = Volumes;
        }
        
        /// <summary>
        /// AllowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field may be added at the pod author&#39;s discretion. You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities.
        /// </summary>
        /// <value>AllowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field may be added at the pod author&#39;s discretion. You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities.</value>
        [DataMember(Name="allowedCapabilities", EmitDefaultValue=false)]
        public List<string> AllowedCapabilities { get; set; }

        /// <summary>
        /// DefaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capabiility in both DefaultAddCapabilities and RequiredDropCapabilities.
        /// </summary>
        /// <value>DefaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capabiility in both DefaultAddCapabilities and RequiredDropCapabilities.</value>
        [DataMember(Name="defaultAddCapabilities", EmitDefaultValue=false)]
        public List<string> DefaultAddCapabilities { get; set; }

        /// <summary>
        /// FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        /// <value>FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.</value>
        [DataMember(Name="fsGroup", EmitDefaultValue=false)]
        public V1beta1FSGroupStrategyOptions FsGroup { get; set; }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        /// <value>hostIPC determines if the policy allows the use of HostIPC in the pod spec.</value>
        [DataMember(Name="hostIPC", EmitDefaultValue=false)]
        public bool? HostIPC { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        /// <value>hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.</value>
        [DataMember(Name="hostNetwork", EmitDefaultValue=false)]
        public bool? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        /// <value>hostPID determines if the policy allows the use of HostPID in the pod spec.</value>
        [DataMember(Name="hostPID", EmitDefaultValue=false)]
        public bool? HostPID { get; set; }

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        /// <value>hostPorts determines which host port ranges are allowed to be exposed.</value>
        [DataMember(Name="hostPorts", EmitDefaultValue=false)]
        public List<V1beta1HostPortRange> HostPorts { get; set; }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        /// <value>privileged determines if a pod can request to be run as privileged.</value>
        [DataMember(Name="privileged", EmitDefaultValue=false)]
        public bool? Privileged { get; set; }

        /// <summary>
        /// ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        /// <value>ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to.</value>
        [DataMember(Name="readOnlyRootFilesystem", EmitDefaultValue=false)]
        public bool? ReadOnlyRootFilesystem { get; set; }

        /// <summary>
        /// RequiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added.
        /// </summary>
        /// <value>RequiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added.</value>
        [DataMember(Name="requiredDropCapabilities", EmitDefaultValue=false)]
        public List<string> RequiredDropCapabilities { get; set; }

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        /// <value>runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.</value>
        [DataMember(Name="runAsUser", EmitDefaultValue=false)]
        public V1beta1RunAsUserStrategyOptions RunAsUser { get; set; }

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        /// <value>seLinux is the strategy that will dictate the allowable labels that may be set.</value>
        [DataMember(Name="seLinux", EmitDefaultValue=false)]
        public V1beta1SELinuxStrategyOptions SeLinux { get; set; }

        /// <summary>
        /// SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
        /// </summary>
        /// <value>SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.</value>
        [DataMember(Name="supplementalGroups", EmitDefaultValue=false)]
        public V1beta1SupplementalGroupsStrategyOptions SupplementalGroups { get; set; }

        /// <summary>
        /// volumes is a white list of allowed volume plugins.  Empty indicates that all plugins may be used.
        /// </summary>
        /// <value>volumes is a white list of allowed volume plugins.  Empty indicates that all plugins may be used.</value>
        [DataMember(Name="volumes", EmitDefaultValue=false)]
        public List<string> Volumes { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class V1beta1PodSecurityPolicySpec {\n");
            sb.Append("  AllowedCapabilities: ").Append(AllowedCapabilities).Append("\n");
            sb.Append("  DefaultAddCapabilities: ").Append(DefaultAddCapabilities).Append("\n");
            sb.Append("  FsGroup: ").Append(FsGroup).Append("\n");
            sb.Append("  HostIPC: ").Append(HostIPC).Append("\n");
            sb.Append("  HostNetwork: ").Append(HostNetwork).Append("\n");
            sb.Append("  HostPID: ").Append(HostPID).Append("\n");
            sb.Append("  HostPorts: ").Append(HostPorts).Append("\n");
            sb.Append("  Privileged: ").Append(Privileged).Append("\n");
            sb.Append("  ReadOnlyRootFilesystem: ").Append(ReadOnlyRootFilesystem).Append("\n");
            sb.Append("  RequiredDropCapabilities: ").Append(RequiredDropCapabilities).Append("\n");
            sb.Append("  RunAsUser: ").Append(RunAsUser).Append("\n");
            sb.Append("  SeLinux: ").Append(SeLinux).Append("\n");
            sb.Append("  SupplementalGroups: ").Append(SupplementalGroups).Append("\n");
            sb.Append("  Volumes: ").Append(Volumes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as V1beta1PodSecurityPolicySpec);
        }

        /// <summary>
        /// Returns true if V1beta1PodSecurityPolicySpec instances are equal
        /// </summary>
        /// <param name="other">Instance of V1beta1PodSecurityPolicySpec to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(V1beta1PodSecurityPolicySpec other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.AllowedCapabilities == other.AllowedCapabilities ||
                    this.AllowedCapabilities != null &&
                    this.AllowedCapabilities.SequenceEqual(other.AllowedCapabilities)
                ) && 
                (
                    this.DefaultAddCapabilities == other.DefaultAddCapabilities ||
                    this.DefaultAddCapabilities != null &&
                    this.DefaultAddCapabilities.SequenceEqual(other.DefaultAddCapabilities)
                ) && 
                (
                    this.FsGroup == other.FsGroup ||
                    this.FsGroup != null &&
                    this.FsGroup.Equals(other.FsGroup)
                ) && 
                (
                    this.HostIPC == other.HostIPC ||
                    this.HostIPC != null &&
                    this.HostIPC.Equals(other.HostIPC)
                ) && 
                (
                    this.HostNetwork == other.HostNetwork ||
                    this.HostNetwork != null &&
                    this.HostNetwork.Equals(other.HostNetwork)
                ) && 
                (
                    this.HostPID == other.HostPID ||
                    this.HostPID != null &&
                    this.HostPID.Equals(other.HostPID)
                ) && 
                (
                    this.HostPorts == other.HostPorts ||
                    this.HostPorts != null &&
                    this.HostPorts.SequenceEqual(other.HostPorts)
                ) && 
                (
                    this.Privileged == other.Privileged ||
                    this.Privileged != null &&
                    this.Privileged.Equals(other.Privileged)
                ) && 
                (
                    this.ReadOnlyRootFilesystem == other.ReadOnlyRootFilesystem ||
                    this.ReadOnlyRootFilesystem != null &&
                    this.ReadOnlyRootFilesystem.Equals(other.ReadOnlyRootFilesystem)
                ) && 
                (
                    this.RequiredDropCapabilities == other.RequiredDropCapabilities ||
                    this.RequiredDropCapabilities != null &&
                    this.RequiredDropCapabilities.SequenceEqual(other.RequiredDropCapabilities)
                ) && 
                (
                    this.RunAsUser == other.RunAsUser ||
                    this.RunAsUser != null &&
                    this.RunAsUser.Equals(other.RunAsUser)
                ) && 
                (
                    this.SeLinux == other.SeLinux ||
                    this.SeLinux != null &&
                    this.SeLinux.Equals(other.SeLinux)
                ) && 
                (
                    this.SupplementalGroups == other.SupplementalGroups ||
                    this.SupplementalGroups != null &&
                    this.SupplementalGroups.Equals(other.SupplementalGroups)
                ) && 
                (
                    this.Volumes == other.Volumes ||
                    this.Volumes != null &&
                    this.Volumes.SequenceEqual(other.Volumes)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.AllowedCapabilities != null)
                    hash = hash * 59 + this.AllowedCapabilities.GetHashCode();
                if (this.DefaultAddCapabilities != null)
                    hash = hash * 59 + this.DefaultAddCapabilities.GetHashCode();
                if (this.FsGroup != null)
                    hash = hash * 59 + this.FsGroup.GetHashCode();
                if (this.HostIPC != null)
                    hash = hash * 59 + this.HostIPC.GetHashCode();
                if (this.HostNetwork != null)
                    hash = hash * 59 + this.HostNetwork.GetHashCode();
                if (this.HostPID != null)
                    hash = hash * 59 + this.HostPID.GetHashCode();
                if (this.HostPorts != null)
                    hash = hash * 59 + this.HostPorts.GetHashCode();
                if (this.Privileged != null)
                    hash = hash * 59 + this.Privileged.GetHashCode();
                if (this.ReadOnlyRootFilesystem != null)
                    hash = hash * 59 + this.ReadOnlyRootFilesystem.GetHashCode();
                if (this.RequiredDropCapabilities != null)
                    hash = hash * 59 + this.RequiredDropCapabilities.GetHashCode();
                if (this.RunAsUser != null)
                    hash = hash * 59 + this.RunAsUser.GetHashCode();
                if (this.SeLinux != null)
                    hash = hash * 59 + this.SeLinux.GetHashCode();
                if (this.SupplementalGroups != null)
                    hash = hash * 59 + this.SupplementalGroups.GetHashCode();
                if (this.Volumes != null)
                    hash = hash * 59 + this.Volumes.GetHashCode();
                return hash;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
